Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-09-22 18:35:57.47952197
>>> :e
No files to edit.
2022-09-22 18:36:39.015195264
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Point
   8  import Graphics.Gloss.Data.Point.Arithmetic
   9  import Graphics.Gloss.Data.Vector
  10  import Graphics.Gloss.Geometry.Angle
  11  
  12  data World
  13      = World
  14      { turtle :: Turtle
  15      , pict   :: Picture 
  16      }
  17      deriving (Eq, Show)
  18  
  19  data Turtle
  20      = Turtle
  21      { position :: Point
  22      , direction :: Float
  23      , pen :: Updown
  24      , thic :: Float
  25      , color :: Color
  26      , showme :: Bool
  27      }
  28      deriving (Eq, Show)
  29  
  30  data Updown
  31      = Up
  32      | Down
  33      deriving (Eq, Show)
  34  
  35  --
  36  
  37  type Instruction = World -> World
  38  
  39  forward :: Float -> Instruction
  40  forward d world = undefined
  41  
  42  newpos :: Float -> Float -> Point -> Point
  43  newpos dir d (x0,y0) = (x0+dx,y0+dy)
  44      where
  45          dx = d * cos a
  46          dy = d * sin a 
  47          a = degToRad (90 - dir)
Ok, no modules loaded.
2022-09-22 18:37:05.441262
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:43:27: error:
    Ambiguous occurrence ‘+’
    It could refer to
       either ‘Prelude.+’,
              imported from ‘Prelude’ at src/World.hs:4:8-12
              (and originally defined in ‘GHC.Num’)
           or ‘Graphics.Gloss.Data.Point.Arithmetic.+’,
              imported from ‘Graphics.Gloss.Data.Point.Arithmetic’ at src/World.hs:8:1-43
   |
43 | newpos dir d (x0,y0) = (x0+dx,y0+dy)
   |                           ^

src/World.hs:43:33: error:
    Ambiguous occurrence ‘+’
    It could refer to
       either ‘Prelude.+’,
              imported from ‘Prelude’ at src/World.hs:4:8-12
              (and originally defined in ‘GHC.Num’)
           or ‘Graphics.Gloss.Data.Point.Arithmetic.+’,
              imported from ‘Graphics.Gloss.Data.Point.Arithmetic’ at src/World.hs:8:1-43
   |
43 | newpos dir d (x0,y0) = (x0+dx,y0+dy)
   |                                 ^

src/World.hs:45:16: error:
    Ambiguous occurrence ‘*’
    It could refer to
       either ‘Prelude.*’,
              imported from ‘Prelude’ at src/World.hs:4:8-12
              (and originally defined in ‘GHC.Num’)
           or ‘Graphics.Gloss.Data.Point.Arithmetic.*’,
              imported from ‘Graphics.Gloss.Data.Point.Arithmetic’ at src/World.hs:8:1-43
   |
45 |         dx = d * cos a
   |                ^

src/World.hs:46:16: error:
    Ambiguous occurrence ‘*’
    It could refer to
       either ‘Prelude.*’,
              imported from ‘Prelude’ at src/World.hs:4:8-12
              (and originally defined in ‘GHC.Num’)
           or ‘Graphics.Gloss.Data.Point.Arithmetic.*’,
              imported from ‘Graphics.Gloss.Data.Point.Arithmetic’ at src/World.hs:8:1-43
   |
46 |         dy = d * sin a 
   |                ^

src/World.hs:47:26: error:
    Ambiguous occurrence ‘-’
    It could refer to
       either ‘Prelude.-’,
              imported from ‘Prelude’ at src/World.hs:4:8-12
              (and originally defined in ‘GHC.Num’)
           or ‘Graphics.Gloss.Data.Point.Arithmetic.-’,
              imported from ‘Graphics.Gloss.Data.Point.Arithmetic’ at src/World.hs:8:1-43
   |
47 |         a = degToRad (90 - dir)
   |                          ^
Failed, no modules loaded.
2022-09-22 18:37:05.629054474
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Point
   8  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
   9  import Graphics.Gloss.Data.Vector
  10  import Graphics.Gloss.Geometry.Angle
  11  
  12  data World
  13      = World
  14      { turtle :: Turtle
  15      , pict   :: Picture 
  16      }
  17      deriving (Eq, Show)
  18  
  19  data Turtle
  20      = Turtle
  21      { position :: Point
  22      , direction :: Float
  23      , pen :: Updown
  24      , thic :: Float
  25      , color :: Color
  26      , showme :: Bool
  27      }
  28      deriving (Eq, Show)
  29  
  30  data Updown
  31      = Up
  32      | Down
  33      deriving (Eq, Show)
  34  
  35  --
  36  
  37  type Instruction = World -> World
  38  
  39  forward :: Float -> Instruction
  40  forward d world = undefined
  41  
  42  newpos :: Float -> Float -> Point -> Point
  43  newpos dir d (x0,y0) = (x0+dx,y0+dy)
  44      where
  45          dx = d * cos a
  46          dy = d * sin a 
  47          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-09-22 18:38:51.05905639
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Point
   8  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
   9  import Graphics.Gloss.Data.Vector
  10  import Graphics.Gloss.Geometry.Angle
  11  
  12  data World
  13      = World
  14      { turtle :: Turtle
  15      , pict   :: Picture 
  16      }
  17      deriving (Eq, Show)
  18  
  19  data Turtle
  20      = Turtle
  21      { position :: Point
  22      , direction :: Float
  23      , pen :: Updown
  24      , thic :: Float
  25      , color :: Color
  26      , showme :: Bool
  27      }
  28      deriving (Eq, Show)
  29  
  30  data Updown
  31      = Up
  32      | Down
  33      deriving (Eq, Show)
  34  
  35  --
  36  
  37  type Instruction = World -> World
  38  
  39  forward :: Float -> Instruction
  40  forward d world = undefined
  41  
  42  newpos :: Float -> Float -> Point -> Point
  43  newpos dir d pos0 = pos0 G.+ diff
  44      where
  45          diff = d * unitVectorAtAngle a
  46          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:43:30: error:
    • Couldn't match type ‘Float’ with ‘(Float, Float)’
      Expected: Point
        Actual: Float
    • In the second argument of ‘(G.+)’, namely ‘diff’
      In the expression: pos0 G.+ diff
      In an equation for ‘newpos’:
          newpos dir d pos0
            = pos0 G.+ diff
            where
                diff = d * unitVectorAtAngle a
                a = degToRad (90 - dir)
   |
43 | newpos dir d pos0 = pos0 G.+ diff
   |                              ^^^^

src/World.hs:45:20: error:
    • Couldn't match type ‘(Float, Float)’ with ‘Float’
      Expected: Float
        Actual: Vector
    • In the second argument of ‘(*)’, namely ‘unitVectorAtAngle a’
      In the expression: d * unitVectorAtAngle a
      In an equation for ‘diff’: diff = d * unitVectorAtAngle a
   |
45 |         diff = d * unitVectorAtAngle a
   |                    ^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-09-22 18:49:21.269130963
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Point
   8  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
   9  import Graphics.Gloss.Data.Vector
  10  import Graphics.Gloss.Geometry.Angle
  11  
  12  data World
  13      = World
  14      { turtle :: Turtle
  15      , pict   :: Picture 
  16      }
  17      deriving (Eq, Show)
  18  
  19  data Turtle
  20      = Turtle
  21      { position :: Point
  22      , direction :: Float
  23      , pen :: Updown
  24      , thic :: Float
  25      , color :: Color
  26      , showme :: Bool
  27      }
  28      deriving (Eq, Show)
  29  
  30  data Updown
  31      = Up
  32      | Down
  33      deriving (Eq, Show)
  34  
  35  --
  36  
  37  type Instruction = World -> World
  38  
  39  forward :: Float -> Instruction
  40  forward d world = undefined
  41  
  42  newpos :: Float -> Float -> Point -> Point
  43  newpos dir d pos0 = pos0 G.+ diff
  44      where
  45          diff = d G.* unitVectorAtAngle a
  46          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-09-22 18:49:58.474627213
>>> newpos 60 100 (0,0)
(86.60254,50.0)
2022-09-22 18:50:40.69626653
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Point
   8  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
   9  import Graphics.Gloss.Data.Vector
  10  import Graphics.Gloss.Geometry.Angle
  11  
  12  data World
  13      = World
  14      { turtle :: Turtle
  15      , pict   :: Picture 
  16      }
  17      deriving (Eq, Show)
  18  
  19  data Turtle
  20      = Turtle
  21      { position :: Point
  22      , direction :: Float
  23      , pen :: Updown
  24      , thic :: Float
  25      , color :: Color
  26      , showme :: Bool
  27      }
  28      deriving (Eq, Show)
  29  
  30  data Updown
  31      = Up
  32      | Down
  33      deriving (Eq, Show)
  34  
  35  --
  36  
  37  type Instruction = World -> World
  38  
  39  forward :: Float -> Instruction
  40  forward d world = world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
  41  
  42  newpos :: Float -> Float -> Point -> Point
  43  newpos dir d pos0 = pos0 G.+ diff
  44      where
  45          diff = d G.* unitVectorAtAngle a
  46          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:40:36: error:
    • Variable not in scope: turtle :: Turtle
    • Perhaps you meant data constructor ‘Turtle’ (line 20)
      NB: ‘turtle’ is a field selector belonging to the type ‘World’
      that has been suppressed by NoFieldSelectors
   |
40 | forward d world = world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
   |                                    ^^^^^^

src/World.hs:40:63: error:
    • Variable not in scope: turtle
    • Perhaps you meant data constructor ‘Turtle’ (line 20)
      NB: ‘turtle’ is a field selector belonging to the type ‘World’
      that has been suppressed by NoFieldSelectors
   |
40 | forward d world = world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
   |                                                               ^^^^^^

src/World.hs:40:82: error:
    • Variable not in scope: turtle
    • Perhaps you meant data constructor ‘Turtle’ (line 20)
      NB: ‘turtle’ is a field selector belonging to the type ‘World’
      that has been suppressed by NoFieldSelectors
   |
40 | forward d world = world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
   |                                                                                  ^^^^^^
Failed, no modules loaded.
2022-09-22 18:59:22.556982559
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Point
   8  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
   9  import Graphics.Gloss.Data.Vector
  10  import Graphics.Gloss.Geometry.Angle
  11  
  12  data World
  13      = World
  14      { turtle :: Turtle
  15      , pict   :: Picture 
  16      }
  17      deriving (Eq, Show)
  18  
  19  data Turtle
  20      = Turtle
  21      { position :: Point
  22      , direction :: Float
  23      , pen :: Updown
  24      , thic :: Float
  25      , color :: Color
  26      , showme :: Bool
  27      }
  28      deriving (Eq, Show)
  29  
  30  data Updown
  31      = Up
  32      | Down
  33      deriving (Eq, Show)
  34  
  35  --
  36  
  37  type Instruction = World -> World
  38  
  39  forward :: Float -> Instruction
  40  forward d world = case world of
  41      World { turtle = turtle } -> world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
  42  
  43  newpos :: Float -> Float -> Point -> Point
  44  newpos dir d pos0 = pos0 G.+ diff
  45      where
  46          diff = d G.* unitVectorAtAngle a
  47          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-09-22 19:04:51.661901522
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Point
   8  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
   9  import Graphics.Gloss.Data.Vector
  10  import Graphics.Gloss.Geometry.Angle
  11  
  12  data World
  13      = World
  14      { turtle :: Turtle
  15      , pict   :: Picture 
  16      }
  17      deriving (Eq, Show)
  18  
  19  defaultWorld :: World
  20  defaultWorld = World { turtle = defaultTurtle 
  21                       , pict = black
  22                       }
  23  data Turtle
  24      = Turtle
  25      { position :: Point
  26      , direction :: Float
  27      , pen :: Updown
  28      , thic :: Float
  29      , color :: Color
  30      , showme :: Bool
  31      }
  32      deriving (Eq, Show)
  33  
  34  defaultTurtle :: Turtle
  35  defaultTurtle = Turtle
  36                { position = (0,0)
  37                , direction = 0
  38                , pen = Up
  39                , thic = 1
  40                , color = black
  41                , showme = False
  42                }
  43  
  44  data Updown
  45      = Up
  46      | Down
  47      deriving (Eq, Show)
  48  
  49  --
  50  
  51  type Instruction = World -> World
  52  
  53  forward :: Float -> Instruction
  54  forward d world = case world of
  55      World { turtle = turtle } -> world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
  56  
  57  newpos :: Float -> Float -> Point -> Point
  58  newpos dir d pos0 = pos0 G.+ diff
  59      where
  60          diff = d G.* unitVectorAtAngle a
  61          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:21:31: error:
    • Couldn't match expected type ‘Picture’ with actual type ‘Color’
    • In the ‘pict’ field of a record
      In the expression: World {turtle = defaultTurtle, pict = black}
      In an equation for ‘defaultWorld’:
          defaultWorld = World {turtle = defaultTurtle, pict = black}
   |
21 |                      , pict = black
   |                               ^^^^^
Failed, no modules loaded.
2022-09-22 19:13:20.574111726
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Color
   8  import Graphics.Gloss.Data.Point
   9  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  10  import Graphics.Gloss.Data.Vector
  11  import Graphics.Gloss.Geometry.Angle
  12  
  13  data World
  14      = World
  15      { turtle :: Turtle
  16      , pict   :: Picture 
  17      }
  18      deriving (Eq, Show)
  19  
  20  defaultWorld :: World
  21  defaultWorld = World { turtle = defaultTurtle 
  22                       , pict = black
  23                       }
  24  data Turtle
  25      = Turtle
  26      { position :: Point
  27      , direction :: Float
  28      , pen :: Updown
  29      , thic :: Float
  30      , color :: Color
  31      , showme :: Bool
  32      }
  33      deriving (Eq, Show)
  34  
  35  defaultTurtle :: Turtle
  36  defaultTurtle = Turtle
  37                { position = (0,0)
  38                , direction = 0
  39                , pen = Up
  40                , thic = 1
  41                , color = black
  42                , showme = False
  43                }
  44  
  45  data Updown
  46      = Up
  47      | Down
  48      deriving (Eq, Show)
  49  
  50  --
  51  
  52  type Instruction = World -> World
  53  
  54  forward :: Float -> Instruction
  55  forward d world = case world of
  56      World { turtle = turtle } -> world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
  57  
  58  newpos :: Float -> Float -> Point -> Point
  59  newpos dir d pos0 = pos0 G.+ diff
  60      where
  61          diff = d G.* unitVectorAtAngle a
  62          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:7:1: error:
    Could not find module ‘Graphics.Gloss.Color’
    Perhaps you meant Graphics.Gloss.Data.Color (from gloss-1.13.2.2)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
7 | import Graphics.Gloss.Color
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-09-22 19:14:52.608458047
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Color
   8  import Graphics.Gloss.Data.Point
   9  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  10  import Graphics.Gloss.Data.Vector
  11  import Graphics.Gloss.Geometry.Angle
  12  
  13  data World
  14      = World
  15      { turtle :: Turtle
  16      , pict   :: Picture 
  17      }
  18      deriving (Eq, Show)
  19  
  20  defaultWorld :: World
  21  defaultWorld = World { turtle = defaultTurtle 
  22                       , pict = black
  23                       }
  24  data Turtle
  25      = Turtle
  26      { position :: Point
  27      , direction :: Float
  28      , pen :: Updown
  29      , thic :: Float
  30      , color :: Color
  31      , showme :: Bool
  32      }
  33      deriving (Eq, Show)
  34  
  35  defaultTurtle :: Turtle
  36  defaultTurtle = Turtle
  37                { position = (0,0)
  38                , direction = 0
  39                , pen = Up
  40                , thic = 1
  41                , color = black
  42                , showme = False
  43                }
  44  
  45  data Updown
  46      = Up
  47      | Down
  48      deriving (Eq, Show)
  49  
  50  --
  51  
  52  type Instruction = World -> World
  53  
  54  forward :: Float -> Instruction
  55  forward d world = case world of
  56      World { turtle = turtle } -> world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
  57  
  58  newpos :: Float -> Float -> Point -> Point
  59  newpos dir d pos0 = pos0 G.+ diff
  60      where
  61          diff = d G.* unitVectorAtAngle a
  62          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:22:31: error:
    • Couldn't match expected type ‘Picture’ with actual type ‘Color’
    • In the ‘pict’ field of a record
      In the expression: World {turtle = defaultTurtle, pict = black}
      In an equation for ‘defaultWorld’:
          defaultWorld = World {turtle = defaultTurtle, pict = black}
   |
22 |                      , pict = black
   |                               ^^^^^
Failed, no modules loaded.
2022-09-22 19:15:18.499959573
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Color
   8  import Graphics.Gloss.Data.Point
   9  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  10  import Graphics.Gloss.Data.Vector
  11  import Graphics.Gloss.Geometry.Angle
  12  
  13  data World
  14      = World
  15      { turtle :: Turtle
  16      , pict   :: Picture 
  17      }
  18      deriving (Eq, Show)
  19  
  20  defaultWorld :: World
  21  defaultWorld = World { turtle = defaultTurtle 
  22                       , pict = blank
  23                       }
  24  data Turtle
  25      = Turtle
  26      { position :: Point
  27      , direction :: Float
  28      , pen :: Updown
  29      , thic :: Float
  30      , color :: Color
  31      , showme :: Bool
  32      }
  33      deriving (Eq, Show)
  34  
  35  defaultTurtle :: Turtle
  36  defaultTurtle = Turtle
  37                { position = (0,0)
  38                , direction = 0
  39                , pen = Up
  40                , thic = 1
  41                , color = black
  42                , showme = False
  43                }
  44  
  45  data Updown
  46      = Up
  47      | Down
  48      deriving (Eq, Show)
  49  
  50  --
  51  
  52  type Instruction = World -> World
  53  
  54  forward :: Float -> Instruction
  55  forward d world = case world of
  56      World { turtle = turtle } -> world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
  57  
  58  newpos :: Float -> Float -> Point -> Point
  59  newpos dir d pos0 = pos0 G.+ diff
  60      where
  61          diff = d G.* unitVectorAtAngle a
  62          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-09-22 19:17:34.854099566
>>> forward 100 (defaultWorld )
World {turtle = Turtle {position = (-4.371139e-6,100.0), direction = 0.0, pen = Up, thic = 1.0, color = RGBA 0.0 0.0 0.0 1.0, showme = False}, pict = Blank}
2022-09-22 19:19:29.710547028
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Color
   8  import Graphics.Gloss.Data.Point
   9  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  10  import Graphics.Gloss.Data.Vector
  11  import Graphics.Gloss.Geometry.Angle
  12  
  13  data World
  14      = World
  15      { turtle :: Turtle
  16      , pict   :: Picture 
  17      }
  18      deriving (Eq, Show)
  19  
  20  defaultWorld :: World
  21  defaultWorld = World { turtle = defaultTurtle 
  22                       , pict = blank
  23                       }
  24  data Turtle
  25      = Turtle
  26      { position :: Point
  27      , direction :: Float
  28      , pen :: Updown
  29      , thic :: Float
  30      , color :: Color
  31      , showme :: Bool
  32      }
  33      deriving (Eq, Show)
  34  
  35  defaultTurtle :: Turtle
  36  defaultTurtle = Turtle
  37                { position = (0,0)
  38                , direction = 60
  39                , pen = Up
  40                , thic = 1
  41                , color = black
  42                , showme = False
  43                }
  44  
  45  data Updown
  46      = Up
  47      | Down
  48      deriving (Eq, Show)
  49  
  50  --
  51  
  52  type Instruction = World -> World
  53  
  54  forward :: Float -> Instruction
  55  forward d world = case world of
  56      World { turtle = turtle } -> world { turtle = turtle { position = newpos turtle.direction d turtle.position }}
  57  
  58  newpos :: Float -> Float -> Point -> Point
  59  newpos dir d pos0 = pos0 G.+ diff
  60      where
  61          diff = d G.* unitVectorAtAngle a
  62          a = degToRad (90 - dir)
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-09-22 19:21:09.752312828
>>> forward 100 (defaultWorld )
World {turtle = Turtle {position = (86.60254,50.0), direction = 60.0, pen = Up, thic = 1.0, color = RGBA 0.0 0.0 0.0 1.0, showme = False}, pict = Blank}
2022-09-22 19:21:14.563534941
>>> Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-06 18:26:25.080151639
>>> :e
No files to edit.
2022-10-06 18:28:17.950398349
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Color
   8  import Graphics.Gloss.Data.Picture
   9  import Graphics.Gloss.Data.Point
  10  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  11  import Graphics.Gloss.Data.Vector
  12  import Graphics.Gloss.Geometry.Angle
  13  
  14  data World
  15      = World
  16      { turtle :: Turtle
  17      , pict   :: Picture 
  18      }
  19      deriving (Eq, Show)
  20  
  21  defaultWorld :: World
  22  defaultWorld = World { turtle = defaultTurtle 
  23                       , pict = defaultTurtle.selfimg
  24                       }
  25  data Turtle
  26      = Turtle
  27      { position :: Point
  28      , direction :: Float
  29      , pen :: Updown
  30      , thic :: Float
  31      , color :: Color
  32      , showme :: Bool
  33      , selfimg :: Picture
  34      }
  35      deriving (Eq, Show)
  36  
  37  defaultTurtle :: Turtle
  38  defaultTurtle = Turtle
  39                { position = (0,0)
  40                , direction = 60
  41                , pen = Down
  42                , thic = 10
  43                , color = black
  44                , showme = True
  45                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  46                }
  47  
  48  data Updown
  49      = Up
  50      | Down
  51      deriving (Eq, Show)
  52  
  53  --
  54  
  55  type Instruction = World -> World
  56  
  57  forward, fd :: Float -> Instruction
  58  forward d world = case world of
  59      World { turtle = turtle } 
  60          -> world { turtle = turtle { position = newpos turtle.direction d turtle.position }
  61                   , pict = case turtle.pen of
  62                      Up   -> blank
  63                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  64                   }
  65  
  66  fd = forward
  67  
  68  back, bk :: Float -> Instruction
  69  back = forward . negate
  70  
  71  bk = back
  72  
  73  newpos :: Float -> Float -> Point -> Point
  74  newpos dir d pos0 = pos0 G.+ diff
  75      where
  76          diff = d G.* unitVectorAtAngle a
  77          a = degToRad (90 - dir)
  78  
  79  spot :: Float -> Point -> Picture
  80  spot thc (x,y)
  81      = translate x y
  82      $ circleSolid (thc / 2)
  83  
  84  dispPict :: Picture -> IO ()
  85  dispPict pict = display FullScreen white pict
  86  
  87  thicLine :: Float -> Float -> Float -> Point -> Picture
  88  thicLine dis dir thc pos1 
  89      = spot thc pos1
  90      <> spot thc pos2
  91      <> translate x y (rotate dir $ rectangleSolid thc dis)
  92      where
  93          (x,y) = 0.5 G.* (pos1 G.+ pos2)
  94          pos2 = newpos dir dis pos1
  95  
  96  dispWorld :: World -> IO ()
  97  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-06 18:28:35.557705016
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-06 18:28:35.7621449
>>> dispWorld defaultWorld
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-06 18:32:06.669651533
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Data.Color
   8  import Graphics.Gloss.Data.Picture
   9  import Graphics.Gloss.Data.Point
  10  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  11  import Graphics.Gloss.Data.Vector
  12  import Graphics.Gloss.Geometry.Angle
  13  
  14  data World
  15      = World
  16      { turtle :: Turtle
  17      , pict   :: Picture 
  18      }
  19      deriving (Eq, Show)
  20  
  21  defaultWorld :: World
  22  defaultWorld = World { turtle = defaultTurtle 
  23                       , pict = defaultTurtle.selfimg
  24                       }
  25  data Turtle
  26      = Turtle
  27      { position :: Point
  28      , direction :: Float
  29      , pen :: Updown
  30      , thic :: Float
  31      , color :: Color
  32      , showme :: Bool
  33      , selfimg :: Picture
  34      }
  35      deriving (Eq, Show)
  36  
  37  defaultTurtle :: Turtle
  38  defaultTurtle = Turtle
  39                { position = (0,0)
  40                , direction = 60
  41                , pen = Down
  42                , thic = 10
  43                , color = black
  44                , showme = True
  45                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  46                }
  47  
  48  data Updown
  49      = Up
  50      | Down
  51      deriving (Eq, Show)
  52  
  53  --
  54  
  55  type Instruction = World -> World
  56  
  57  forward, fd :: Float -> Instruction
  58  forward d world = case world of
  59      World { turtle = turtle } 
  60          -> world { turtle = turtle { position = newpos turtle.direction d turtle.position }
  61                   , pict = case turtle.pen of
  62                      Up   -> blank
  63                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  64                   }
  65  
  66  fd = forward
  67  
  68  back, bk :: Float -> Instruction
  69  back = forward . negate
  70  
  71  bk = back
  72  
  73  newpos :: Float -> Float -> Point -> Point
  74  newpos dir d pos0 = pos0 G.+ diff
  75      where
  76          diff = d G.* unitVectorAtAngle a
  77          a = degToRad (90 - dir)
  78  
  79  spot :: Float -> Point -> Picture
  80  spot thc (x,y)
  81      = translate x y
  82      $ circleSolid (thc / 2)
  83  
  84  dispPict :: Picture -> IO ()
  85  dispPict pict = display FullScreen white pict
  86  
  87  thicLine :: Float -> Float -> Float -> Point -> Picture
  88  thicLine dis dir thc pos1 
  89      = spot thc pos1
  90      <> spot thc pos2
  91      <> translate x y (rotate dir $ rectangleSolid thc dis)
  92      where
  93          (x,y) = 0.5 G.* (pos1 G.+ pos2)
  94          pos2 = newpos dir dis pos1
  95  
  96  dispWorld :: World -> IO ()
  97  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-06 18:32:20.674120607
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-06 18:32:20.909735265
>>> dispWorld defaultWorld
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
free(): corrupted unsorted chunks
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-06 18:46:09.094073444
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.posision
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  newpos :: Float -> Float -> Point -> Point
  78  newpos dir d pos0 = pos0 G.+ diff
  79      where
  80          diff = d G.* unitVectorAtAngle a
  81          a = degToRad (90 - dir)
  82  
  83  spot :: Float -> Point -> Picture
  84  spot thc (x,y)
  85      = translate x y
  86      $ circleSolid (thc / 2)
  87  
  88  dispPict :: Picture -> IO ()
  89  dispPict pict = display FullScreen white pict
  90  
  91  thicLine :: Float -> Float -> Float -> Point -> Picture
  92  thicLine dis dir thc pos1 
  93      = spot thc pos1
  94      <> spot thc pos2
  95      <> translate x y (rotate dir $ rectangleSolid thc dis)
  96      where
  97          (x,y) = 0.5 G.* (pos1 G.+ pos2)
  98          pos2 = newpos dir dis pos1
  99  
 100  dispWorld :: World -> IO ()
 101  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-06 18:46:21.435021396
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:67:53: error:
    • No instance for (GHC.Records.HasField "posision" Turtle Point)
        arising from selecting the field ‘posision’
    • In the third argument of ‘newpos’, namely ‘turtle.posision’
      In the expression: newpos turtle.direction d turtle.posision
      In a pattern binding:
        (x', y') = newpos turtle.direction d turtle.posision
   |
67 |                 (x',y') = newpos turtle.direction d turtle.posision
   |                                                     ^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-10-06 18:46:21.603871185
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  newpos :: Float -> Float -> Point -> Point
  78  newpos dir d pos0 = pos0 G.+ diff
  79      where
  80          diff = d G.* unitVectorAtAngle a
  81          a = degToRad (90 - dir)
  82  
  83  spot :: Float -> Point -> Picture
  84  spot thc (x,y)
  85      = translate x y
  86      $ circleSolid (thc / 2)
  87  
  88  dispPict :: Picture -> IO ()
  89  dispPict pict = display FullScreen white pict
  90  
  91  thicLine :: Float -> Float -> Float -> Point -> Picture
  92  thicLine dis dir thc pos1 
  93      = spot thc pos1
  94      <> spot thc pos2
  95      <> translate x y (rotate dir $ rectangleSolid thc dis)
  96      where
  97          (x,y) = 0.5 G.* (pos1 G.+ pos2)
  98          pos2 = newpos dir dis pos1
  99  
 100  dispWorld :: World -> IO ()
 101  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-06 18:46:40.301692436
>>> dispWorld (fd 200 defaultWorld )
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-06 18:58:10.364431325
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  right, rt :: Float -> Instruction 
  78  right dir world = case world of
  79      World { turtle = turtle } 
  80          -> world { turtle = turtle { direction = newdir }
  81                   , pict = bool blank selfimg' turtle.showme
  82                   }
  83              where
  84                  newdir = turtle.direction + dir
  85                  selfimg' = translate turtle.position (rotate newdir turtle.selfimg)
  86  
  87  -- utilities
  88  
  89  newpos :: Float -> Float -> Point -> Point
  90  newpos dir d pos0 = pos0 G.+ diff
  91      where
  92          diff = d G.* unitVectorAtAngle a
  93          a = degToRad (90 - dir)
  94  
  95  spot :: Float -> Point -> Picture
  96  spot thc (x,y)
  97      = translate x y
  98      $ circleSolid (thc / 2)
  99  
 100  dispPict :: Picture -> IO ()
 101  dispPict pict = display FullScreen white pict
 102  
 103  thicLine :: Float -> Float -> Float -> Point -> Picture
 104  thicLine dis dir thc pos1 
 105      = spot thc pos1
 106      <> spot thc pos2
 107      <> translate x y (rotate dir $ rectangleSolid thc dis)
 108      where
 109          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 110          pos2 = newpos dir dis pos1
 111  
 112  dispWorld :: World -> IO ()
 113  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-06 18:58:21.973984137
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:77:8: error:
    The type signature for ‘rt’ lacks an accompanying binding
   |
77 | right, rt :: Float -> Instruction 
   |        ^^
Failed, no modules loaded.
2022-10-06 18:58:22.098987389
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  right, rt :: Float -> Instruction 
  78  right dir world = case world of
  79      World { turtle = turtle } 
  80          -> world { turtle = turtle { direction = newdir }
  81                   , pict = bool blank selfimg' turtle.showme
  82                   }
  83              where
  84                  newdir = turtle.direction + dir
  85                  selfimg' = translate turtle.position (rotate newdir turtle.selfimg)
  86  
  87  rt = right
  88  
  89  -- utilities
  90  
  91  newpos :: Float -> Float -> Point -> Point
  92  newpos dir d pos0 = pos0 G.+ diff
  93      where
  94          diff = d G.* unitVectorAtAngle a
  95          a = degToRad (90 - dir)
  96  
  97  spot :: Float -> Point -> Picture
  98  spot thc (x,y)
  99      = translate x y
 100      $ circleSolid (thc / 2)
 101  
 102  dispPict :: Picture -> IO ()
 103  dispPict pict = display FullScreen white pict
 104  
 105  thicLine :: Float -> Float -> Float -> Point -> Picture
 106  thicLine dis dir thc pos1 
 107      = spot thc pos1
 108      <> spot thc pos2
 109      <> translate x y (rotate dir $ rectangleSolid thc dis)
 110      where
 111          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 112          pos2 = newpos dir dis pos1
 113  
 114  dispWorld :: World -> IO ()
 115  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:81:38: error:
    • Couldn't match expected type ‘Picture’
                  with actual type ‘Picture -> Picture’
    • Probable cause: ‘selfimg'’ is applied to too few arguments
      In the second argument of ‘bool’, namely ‘selfimg'’
      In the ‘pict’ field of a record
      In the expression:
        world
          {turtle = turtle {direction = newdir},
           pict = bool blank selfimg' turtle.showme}
   |
81 |                  , pict = bool blank selfimg' turtle.showme
   |                                      ^^^^^^^^

src/World.hs:85:38: error:
    • Couldn't match type ‘(Float, Float)’ with ‘Float’
        arising from selecting the field ‘position’
    • In the first argument of ‘translate’, namely ‘turtle.position’
      In the expression:
        translate turtle.position (rotate newdir turtle.selfimg)
      In an equation for ‘selfimg'’:
          selfimg' = translate turtle.position (rotate newdir turtle.selfimg)
   |
85 |                 selfimg' = translate turtle.position (rotate newdir turtle.selfimg)
   |                                      ^^^^^^^^^^^^^^^

src/World.hs:85:55: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Picture’
    • In the second argument of ‘translate’, namely
        ‘(rotate newdir turtle.selfimg)’
      In the expression:
        translate turtle.position (rotate newdir turtle.selfimg)
      In an equation for ‘selfimg'’:
          selfimg' = translate turtle.position (rotate newdir turtle.selfimg)
   |
85 |                 selfimg' = translate turtle.position (rotate newdir turtle.selfimg)
   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-10-06 18:59:00.036407656
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  right, rt :: Float -> Instruction 
  78  right dir world = case world of
  79      World { turtle = turtle } 
  80          -> world { turtle = turtle { direction = newdir }
  81                   , pict = bool blank selfimg' turtle.showme
  82                   }
  83              where
  84                  newdir = turtle.direction + dir
  85                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  86  
  87  rt = right
  88  
  89  -- utilities
  90  
  91  newpos :: Float -> Float -> Point -> Point
  92  newpos dir d pos0 = pos0 G.+ diff
  93      where
  94          diff = d G.* unitVectorAtAngle a
  95          a = degToRad (90 - dir)
  96  
  97  spot :: Float -> Point -> Picture
  98  spot thc (x,y)
  99      = translate x y
 100      $ circleSolid (thc / 2)
 101  
 102  dispPict :: Picture -> IO ()
 103  dispPict pict = display FullScreen white pict
 104  
 105  thicLine :: Float -> Float -> Float -> Point -> Picture
 106  thicLine dis dir thc pos1 
 107      = spot thc pos1
 108      <> spot thc pos2
 109      <> translate x y (rotate dir $ rectangleSolid thc dis)
 110      where
 111          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 112          pos2 = newpos dir dis pos1
 113  
 114  dispWorld :: World -> IO ()
 115  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-06 19:00:17.455597341
>>> :t uncurry
uncurry :: (a -> b -> c) -> (a, b) -> c
2022-10-06 19:02:40.884853955
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  -- utilities
 109  
 110  newpos :: Float -> Float -> Point -> Point
 111  newpos dir d pos0 = pos0 G.+ diff
 112      where
 113          diff = d G.* unitVectorAtAngle a
 114          a = degToRad (90 - dir)
 115  
 116  spot :: Float -> Point -> Picture
 117  spot thc (x,y)
 118      = translate x y
 119      $ circleSolid (thc / 2)
 120  
 121  dispPict :: Picture -> IO ()
 122  dispPict pict = display FullScreen white pict
 123  
 124  thicLine :: Float -> Float -> Float -> Point -> Picture
 125  thicLine dis dir thc pos1 
 126      = spot thc pos1
 127      <> spot thc pos2
 128      <> translate x y (rotate dir $ rectangleSolid thc dis)
 129      where
 130          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 131          pos2 = newpos dir dis pos1
 132  
 133  dispWorld :: World -> IO ()
 134  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:95:19: error:
    • Variable not in scope: world :: World
    • Perhaps you meant data constructor ‘World’ (line 16)
   |
95 | setxy x y =  case world of
   |                   ^^^^^

src/World.hs:97:12: error:
    • Variable not in scope: world :: World
    • Perhaps you meant data constructor ‘World’ (line 16)
   |
97 |         -> world { turtle = turtle { position = (x,y) }
   |            ^^^^^
Failed, no modules loaded.
2022-10-06 19:22:32.043752625
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  -- utilities
 109  
 110  newpos :: Float -> Float -> Point -> Point
 111  newpos dir d pos0 = pos0 G.+ diff
 112      where
 113          diff = d G.* unitVectorAtAngle a
 114          a = degToRad (90 - dir)
 115  
 116  spot :: Float -> Point -> Picture
 117  spot thc (x,y)
 118      = translate x y
 119      $ circleSolid (thc / 2)
 120  
 121  dispPict :: Picture -> IO ()
 122  dispPict pict = display FullScreen white pict
 123  
 124  thicLine :: Float -> Float -> Float -> Point -> Picture
 125  thicLine dis dir thc pos1 
 126      = spot thc pos1
 127      <> spot thc pos2
 128      <> translate x y (rotate dir $ rectangleSolid thc dis)
 129      where
 130          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 131          pos2 = newpos dir dis pos1
 132  
 133  dispWorld :: World -> IO ()
 134  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-06 19:22:49.381793581
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  -- utilities
 123  
 124  newpos :: Float -> Float -> Point -> Point
 125  newpos dir d pos0 = pos0 G.+ diff
 126      where
 127          diff = d G.* unitVectorAtAngle a
 128          a = degToRad (90 - dir)
 129  
 130  spot :: Float -> Point -> Picture
 131  spot thc (x,y)
 132      = translate x y
 133      $ circleSolid (thc / 2)
 134  
 135  dispPict :: Picture -> IO ()
 136  dispPict pict = display FullScreen white pict
 137  
 138  thicLine :: Float -> Float -> Float -> Point -> Picture
 139  thicLine dis dir thc pos1 
 140      = spot thc pos1
 141      <> spot thc pos2
 142      <> translate x y (rotate dir $ rectangleSolid thc dis)
 143      where
 144          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 145          pos2 = newpos dir dis pos1
 146  
 147  dispWorld :: World -> IO ()
 148  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-06 19:28:41.723412779
>>> :q
Leaving GHCi.
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-20 18:38:42.260948096
>>> display Fullscreen white $ thicArc (degToRad 30) (degToRad 90) 100 10

<interactive>:1:1: error:
    Variable not in scope: display :: t6 -> t7 -> a0 -> b

<interactive>:1:9: error: Data constructor not in scope: Fullscreen

<interactive>:1:20: error: Variable not in scope: white

<interactive>:1:28: error:
    Variable not in scope: thicArc :: t2 -> t3 -> t4 -> t5 -> a0

<interactive>:1:37: error:
    Variable not in scope: degToRad :: t1 -> t2

<interactive>:1:51: error:
    Variable not in scope: degToRad :: t0 -> t3
2022-10-20 18:41:59.909712843
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> heading 0 (setxy 0 0 world )
 133  
 134  
 135  -- utilities
 136  
 137  newpos :: Float -> Float -> Point -> Point
 138  newpos dir d pos0 = pos0 G.+ diff
 139      where
 140          diff = d G.* unitVectorAtAngle a
 141          a = degToRad (90 - dir)
 142  
 143  spot :: Float -> Point -> Picture
 144  spot thc (x,y)
 145      = translate x y
 146      $ circleSolid (thc / 2)
 147  
 148  dispPict :: Picture -> IO ()
 149  dispPict pict = display FullScreen white pict
 150  
 151  thicLine :: Float -> Float -> Float -> Point -> Picture
 152  thicLine dis dir thc pos1 
 153      = spot thc pos1
 154      <> spot thc pos2
 155      <> translate x y (rotate dir $ rectangleSolid thc dis)
 156      where
 157          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 158          pos2 = newpos dir dis pos1
 159  
 160  dispWorld :: World -> IO ()
 161  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-20 18:43:03.236711703
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:132:12: error:
    Variable not in scope: heading :: t0 -> World -> World
    |
132 |         -> heading 0 (setxy 0 0 world )
    |            ^^^^^^^
Failed, no modules loaded.
2022-10-20 18:43:03.424995954
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  
 135  -- utilities
 136  
 137  newpos :: Float -> Float -> Point -> Point
 138  newpos dir d pos0 = pos0 G.+ diff
 139      where
 140          diff = d G.* unitVectorAtAngle a
 141          a = degToRad (90 - dir)
 142  
 143  spot :: Float -> Point -> Picture
 144  spot thc (x,y)
 145      = translate x y
 146      $ circleSolid (thc / 2)
 147  
 148  dispPict :: Picture -> IO ()
 149  dispPict pict = display FullScreen white pict
 150  
 151  thicLine :: Float -> Float -> Float -> Point -> Picture
 152  thicLine dis dir thc pos1 
 153      = spot thc pos1
 154      <> spot thc pos2
 155      <> translate x y (rotate dir $ rectangleSolid thc dis)
 156      where
 157          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 158          pos2 = newpos dir dis pos1
 159  
 160  dispWorld :: World -> IO ()
 161  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 18:43:34.241457624
>>> display Fullscreen white $ thicArc (degToRad 30) (degToRad 90) 100 10

<interactive>:5:9: error:
    • Data constructor not in scope: Fullscreen :: Display
    • Perhaps you meant ‘FullScreen’ (imported from Graphics.Gloss)

<interactive>:5:28: error:
    • Variable not in scope:
        thicArc :: Float -> Float -> t0 -> t1 -> Picture
    • Perhaps you meant one of these:
        ‘thickArc’ (imported from Graphics.Gloss.Data.Picture),
        data constructor ‘ThickArc’ (imported from Graphics.Gloss.Data.Picture)
2022-10-20 18:43:40.836721764
>>> display FullScreen white $ thickArc (degToRad 30) (degToRad 90) 100 10
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-20 18:46:03.859197025
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  
 135  -- utilities
 136  
 137  newpos :: Float -> Float -> Point -> Point
 138  newpos dir d pos0 = pos0 G.+ diff
 139      where
 140          diff = d G.* unitVectorAtAngle a
 141          a = degToRad (90 - dir)
 142  
 143  spot :: Float -> Point -> Picture
 144  spot thc (x,y)
 145      = translate x y
 146      $ circleSolid (thc / 2)
 147  
 148  dispPict :: Picture -> IO ()
 149  dispPict pict = display FullScreen white pict
 150  
 151  thicLine :: Float -> Float -> Float -> Point -> Picture
 152  thicLine dis dir thc pos1 
 153      = spot thc pos1
 154      <> spot thc pos2
 155      <> translate x y (rotate dir $ rectangleSolid thc dis)
 156      where
 157          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 158          pos2 = newpos dir dis pos1
 159  
 160  dispWorld :: World -> IO ()
 161  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-20 18:46:18.651076231
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 18:46:18.905209924
>>> test = thickArc 30 90 100 10
2022-10-20 18:48:08.785944004
>>> display FullScreen white test
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-20 19:09:25.830620132
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = bool blank selfimg' turtle.showme
 139                              <> thickArc (90-(turtle.direction+t))
 140                                          (90-turtle.direction)
 141                                          r turtle.thic
 142                   }
 143              where
 144                  selfimg' = rotate t turtle.selfimg
 145  
 146  -- utilities
 147  
 148  newpos :: Float -> Float -> Point -> Point
 149  newpos dir d pos0 = pos0 G.+ diff
 150      where
 151          diff = d G.* unitVectorAtAngle a
 152          a = degToRad (90 - dir)
 153  
 154  spot :: Float -> Point -> Picture
 155  spot thc (x,y)
 156      = translate x y
 157      $ circleSolid (thc / 2)
 158  
 159  dispPict :: Picture -> IO ()
 160  dispPict pict = display FullScreen white pict
 161  
 162  thicLine :: Float -> Float -> Float -> Point -> Picture
 163  thicLine dis dir thc pos1 
 164      = spot thc pos1
 165      <> spot thc pos2
 166      <> translate x y (rotate dir $ rectangleSolid thc dis)
 167      where
 168          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 169          pos2 = newpos dir dis pos1
 170  
 171  dispWorld :: World -> IO ()
 172  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-20 19:09:40.886324649
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 19:09:41.111252556
>>> Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-20 19:16:34.866233916
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ thickArc (90-(d+p)) (90-d) r turtle.thic
 146  
 147  -- utilities
 148  
 149  newpos :: Float -> Float -> Point -> Point
 150  newpos dir d pos0 = pos0 G.+ diff
 151      where
 152          diff = d G.* unitVectorAtAngle a
 153          a = degToRad (90 - dir)
 154  
 155  spot :: Float -> Point -> Picture
 156  spot thc (x,y)
 157      = translate x y
 158      $ circleSolid (thc / 2)
 159  
 160  dispPict :: Picture -> IO ()
 161  dispPict pict = display FullScreen white pict
 162  
 163  thicLine :: Float -> Float -> Float -> Point -> Picture
 164  thicLine dis dir thc pos1 
 165      = spot thc pos1
 166      <> spot thc pos2
 167      <> translate x y (rotate dir $ rectangleSolid thc dis)
 168      where
 169          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 170          pos2 = newpos dir dis pos1
 171  
 172  dispWorld :: World -> IO ()
 173  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-20 19:16:52.947635292
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:145:56: error: Variable not in scope: p :: Float
    |
145 |                 tarc = translate x y $ thickArc (90-(d+p)) (90-d) r turtle.thic
    |                                                        ^
Failed, no modules loaded.
2022-10-20 19:16:53.113083989
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import Graphics.Gloss.Data.Picture
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ thickArc (90-(d+t)) (90-d) r turtle.thic
 146  
 147  -- utilities
 148  
 149  newpos :: Float -> Float -> Point -> Point
 150  newpos dir d pos0 = pos0 G.+ diff
 151      where
 152          diff = d G.* unitVectorAtAngle a
 153          a = degToRad (90 - dir)
 154  
 155  spot :: Float -> Point -> Picture
 156  spot thc (x,y)
 157      = translate x y
 158      $ circleSolid (thc / 2)
 159  
 160  dispPict :: Picture -> IO ()
 161  dispPict pict = display FullScreen white pict
 162  
 163  thicLine :: Float -> Float -> Float -> Point -> Picture
 164  thicLine dis dir thc pos1 
 165      = spot thc pos1
 166      <> spot thc pos2
 167      <> translate x y (rotate dir $ rectangleSolid thc dis)
 168      where
 169          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 170          pos2 = newpos dir dis pos1
 171  
 172  dispWorld :: World -> IO ()
 173  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 19:17:08.878173422
>>> dispWorld (arc 120 100 defaultWorld)

<interactive>:4:12: error:
    Ambiguous occurrence ‘arc’
    It could refer to
       either ‘Graphics.Gloss.Data.Picture.arc’,
              imported from ‘Graphics.Gloss.Data.Picture’ at src/World.hs:9:1-34
           or ‘World.arc’, defined at src/World.hs:135:1
2022-10-20 19:18:17.298002001
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ thickArc (90-(d+t)) (90-d) r turtle.thic
 146  
 147  -- utilities
 148  
 149  newpos :: Float -> Float -> Point -> Point
 150  newpos dir d pos0 = pos0 G.+ diff
 151      where
 152          diff = d G.* unitVectorAtAngle a
 153          a = degToRad (90 - dir)
 154  
 155  spot :: Float -> Point -> Picture
 156  spot thc (x,y)
 157      = translate x y
 158      $ circleSolid (thc / 2)
 159  
 160  dispPict :: Picture -> IO ()
 161  dispPict pict = display FullScreen white pict
 162  
 163  thicLine :: Float -> Float -> Float -> Point -> Picture
 164  thicLine dis dir thc pos1 
 165      = spot thc pos1
 166      <> spot thc pos2
 167      <> translate x y (rotate dir $ rectangleSolid thc dis)
 168      where
 169          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 170          pos2 = newpos dir dis pos1
 171  
 172  dispWorld :: World -> IO ()
 173  dispWorld world = dispPict world.pict
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 19:20:18.158205435
>>> :q
Leaving GHCi.
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-20 19:20:57.339772803
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ thickArc (90-(d+t)) (90-d) r turtle.thic
 146  
 147  -- utilities
 148  
 149  newpos :: Float -> Float -> Point -> Point
 150  newpos dir d pos0 = pos0 G.+ diff
 151      where
 152          diff = d G.* unitVectorAtAngle a
 153          a = degToRad (90 - dir)
 154  
 155  spot :: Float -> Point -> Picture
 156  spot thc (x,y)
 157      = translate x y
 158      $ circleSolid (thc / 2)
 159  
 160  dispPict :: Picture -> IO ()
 161  dispPict pict = display FullScreen white pict
 162  
 163  thicLine :: Float -> Float -> Float -> Point -> Picture
 164  thicLine dis dir thc pos1 
 165      = spot thc pos1
 166      <> spot thc pos2
 167      <> translate x y (rotate dir $ rectangleSolid thc dis)
 168      where
 169          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 170          pos2 = newpos dir dis pos1
 171  
 172  dispWorld :: World -> IO ()
 173  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-20 19:21:05.621874084
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 19:21:05.896552189
>>> dispWorld (arc 120 100 defaultWorld)

<interactive>:3:12: error:
    Ambiguous occurrence ‘arc’
    It could refer to
       either ‘Graphics.Gloss.arc’,
              imported from ‘Graphics.Gloss’ at src/World.hs:7:1-21
              (and originally defined in ‘Graphics.Gloss.Data.Picture’)
           or ‘World.arc’, defined at src/World.hs:135:1
2022-10-20 19:21:22.678871899
>>> dispWorld (World.arc 120 100 defaultWorld)
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-20 19:26:48.856226051
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ thickArc (90-d) (90-(d+t)) r turtle.thic
 146  
 147  -- utilities
 148  
 149  newpos :: Float -> Float -> Point -> Point
 150  newpos dir d pos0 = pos0 G.+ diff
 151      where
 152          diff = d G.* unitVectorAtAngle a
 153          a = degToRad (90 - dir)
 154  
 155  spot :: Float -> Point -> Picture
 156  spot thc (x,y)
 157      = translate x y
 158      $ circleSolid (thc / 2)
 159  
 160  dispPict :: Picture -> IO ()
 161  dispPict pict = display FullScreen white pict
 162  
 163  thicLine :: Float -> Float -> Float -> Point -> Picture
 164  thicLine dis dir thc pos1 
 165      = spot thc pos1
 166      <> spot thc pos2
 167      <> translate x y (rotate dir $ rectangleSolid thc dis)
 168      where
 169          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 170          pos2 = newpos dir dis pos1
 171  
 172  dispWorld :: World -> IO ()
 173  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-20 19:26:52.080585593
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 19:26:52.352043572
>>> dispWorld (World.arc 120 100 defaultWorld)
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-20 19:33:00.204017056
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ thickArc 0 90 r turtle.thic
 146  
 147  -- utilities
 148  
 149  newpos :: Float -> Float -> Point -> Point
 150  newpos dir d pos0 = pos0 G.+ diff
 151      where
 152          diff = d G.* unitVectorAtAngle a
 153          a = degToRad (90 - dir)
 154  
 155  spot :: Float -> Point -> Picture
 156  spot thc (x,y)
 157      = translate x y
 158      $ circleSolid (thc / 2)
 159  
 160  dispPict :: Picture -> IO ()
 161  dispPict pict = display FullScreen white pict
 162  
 163  thicLine :: Float -> Float -> Float -> Point -> Picture
 164  thicLine dis dir thc pos1 
 165      = spot thc pos1
 166      <> spot thc pos2
 167      <> translate x y (rotate dir $ rectangleSolid thc dis)
 168      where
 169          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 170          pos2 = newpos dir dis pos1
 171  
 172  dispWorld :: World -> IO ()
 173  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-20 19:33:02.962899533
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 19:33:03.199645218
>>> dispWorld (World.arc 120 100 defaultWorld)
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-20 19:35:09.889940045
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 146  
 147  -- utilities
 148  
 149  newpos :: Float -> Float -> Point -> Point
 150  newpos dir d pos0 = pos0 G.+ diff
 151      where
 152          diff = d G.* unitVectorAtAngle a
 153          a = degToRad (90 - dir)
 154  
 155  spot :: Float -> Point -> Picture
 156  spot thc (x,y)
 157      = translate x y
 158      $ circleSolid (thc / 2)
 159  
 160  dispPict :: Picture -> IO ()
 161  dispPict pict = display FullScreen white pict
 162  
 163  thicLine :: Float -> Float -> Float -> Point -> Picture
 164  thicLine dis dir thc pos1 
 165      = spot thc pos1
 166      <> spot thc pos2
 167      <> translate x y (rotate dir $ rectangleSolid thc dis)
 168      where
 169          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 170          pos2 = newpos dir dis pos1
 171  
 172  dispWorld :: World -> IO ()
 173  dispWorld world = dispPict world.pict
Ok, no modules loaded.
2022-10-20 19:35:11.79541933
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-20 19:35:12.030474539
>>> dispWorld (World.arc 120 100 defaultWorld)
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-27 19:22:47.09434105
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Maybe Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = Just defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = Just $ bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = Just $ bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = Just $ bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = Just $ bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 146  
 147  penup :: Instruction 
 148  penup world = case world of
 149      World { turtle = turtle }
 150          -> world { turtle = turtle { pen = Up }
 151                   }
 152  
 153  pendown :: Instruction 
 154  pendown world = case world of
 155      World { turtle = turtle }
 156          -> world { turtle = turtle { pen = Down }
 157                   }
 158  
 159  clean :: Instruction
 160  clean world = world { pict = Nothing }
 161  
 162  clearscreen :: Instruction
 163  clearscreen = clean . home
 164  
 165  -- utilities
 166  
 167  newpos :: Float -> Float -> Point -> Point
 168  newpos dir d pos0 = pos0 G.+ diff
 169      where
 170          diff = d G.* unitVectorAtAngle a
 171          a = degToRad (90 - dir)
 172  
 173  spot :: Float -> Point -> Picture
 174  spot thc (x,y)
 175      = translate x y
 176      $ circleSolid (thc / 2)
 177  
 178  dispPict :: Picture -> IO ()
 179  dispPict pict = display FullScreen white pict
 180  
 181  thicLine :: Float -> Float -> Float -> Point -> Picture
 182  thicLine dis dir thc pos1 
 183      = spot thc pos1
 184      <> spot thc pos2
 185      <> translate x y (rotate dir $ rectangleSolid thc dis)
 186      where
 187          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 188          pos2 = newpos dir dis pos1
 189  
 190  dispWorld :: World -> IO ()
 191  dispWorld world = maybe (dispPict blank) dispPict world.pict
Ok, no modules loaded.
2022-10-27 19:23:00.027436589
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-27 19:23:00.407787081
>>> dispWorld (fd 200 defaultWorld)
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-10-27 19:25:33.419933139
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { turtle :: Turtle
  18      , pict   :: Maybe Picture 
  19      }
  20      deriving (Eq, Show)
  21  
  22  defaultWorld :: World
  23  defaultWorld = World { turtle = defaultTurtle 
  24                       , pict = Just defaultTurtle.selfimg
  25                       }
  26  data Turtle
  27      = Turtle
  28      { position :: Point
  29      , direction :: Float
  30      , pen :: Updown
  31      , thic :: Float
  32      , color :: Color
  33      , showme :: Bool
  34      , selfimg :: Picture
  35      }
  36      deriving (Eq, Show)
  37  
  38  defaultTurtle :: Turtle
  39  defaultTurtle = Turtle
  40                { position = (0,0)
  41                , direction = 60
  42                , pen = Down
  43                , thic = 10
  44                , color = black
  45                , showme = True
  46                , selfimg = lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  47                }
  48  
  49  data Updown
  50      = Up
  51      | Down
  52      deriving (Eq, Show)
  53  
  54  --
  55  
  56  type Instruction = World -> World
  57  
  58  forward, fd :: Float -> Instruction
  59  forward d world = case world of
  60      World { turtle = turtle } 
  61          -> world { turtle = turtle { position = (x',y') }
  62                   , pict = Just $ bool blank selfimg' turtle.showme <> case turtle.pen of
  63                      Up   -> blank
  64                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  65                   }
  66              where
  67                  (x',y') = newpos turtle.direction d turtle.position
  68                  selfimg' = translate x' y' (rotate turtle.direction turtle.selfimg)
  69  
  70  fd = forward
  71  
  72  back, bk :: Float -> Instruction
  73  back = forward . negate
  74  
  75  bk = back
  76  
  77  left, lt :: Float -> Instruction
  78  left = right . negate
  79  
  80  lt = left
  81  
  82  right, rt :: Float -> Instruction 
  83  right dir world = case world of
  84      World { turtle = turtle } 
  85          -> world { turtle = turtle { direction = newdir }
  86                   , pict = Just $ bool blank selfimg' turtle.showme
  87                   }
  88              where
  89                  newdir = turtle.direction + dir
  90                  selfimg' = uncurry translate turtle.position (rotate newdir turtle.selfimg)
  91  
  92  rt = right
  93  
  94  setxy :: Float -> Float -> Instruction
  95  setxy x y world =  case world of
  96      World { turtle = turtle } 
  97          -> world { turtle = turtle { position = (x,y) }
  98                   , pict = Just $ bool blank selfimg' turtle.showme <> case turtle.pen of
  99                      Up   -> blank
 100                      Down -> thicLine dist dir turtle.thic turtle.position
 101                   }
 102              where
 103                  vec = (x,y) G.- turtle.position
 104                  dist = magV vec
 105                  dir = radToDeg (angleVV (0,1) vec)
 106                  selfimg' = translate x y turtle.selfimg
 107  
 108  setx :: Float -> Instruction
 109  setx x world = case world of
 110      World { turtle = turtle } 
 111          -> setxy x y world
 112          where
 113              (_,y) = turtle.position
 114  
 115  sety :: Float -> Instruction
 116  sety y world = case world of
 117      World { turtle = turtle } 
 118          -> setxy x y world
 119          where
 120              (x,_) = turtle.position
 121  
 122  setheading :: Float -> Instruction
 123  setheading h world = case world of
 124      World { turtle = turtle } 
 125          -> right (h-d) world
 126          where
 127              d = turtle.direction
 128  
 129  home :: Instruction
 130  home world = case world of
 131      World { turtle = turtle } 
 132          -> setheading 0 (setxy 0 0 world )
 133  
 134  arc :: Float -> Float -> Instruction
 135  arc t r world = case world of
 136      World { turtle = turtle }
 137          -> world { turtle = turtle { direction = turtle.direction + t }
 138                   , pict = Just $ bool blank selfimg' turtle.showme
 139                              <> tarc 
 140                   }
 141              where
 142                  selfimg' = translate x y $ rotate (d+t) turtle.selfimg
 143                  (x,y) = turtle.position
 144                  d = turtle.direction
 145                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 146  
 147  penup :: Instruction 
 148  penup world = case world of
 149      World { turtle = turtle }
 150          -> world { turtle = turtle { pen = Up }
 151                   }
 152  
 153  pendown :: Instruction 
 154  pendown world = case world of
 155      World { turtle = turtle }
 156          -> world { turtle = turtle { pen = Down }
 157                   }
 158  
 159  clean :: Instruction
 160  clean world = world { pict = Nothing }
 161  
 162  clearscreen :: Instruction
 163  clearscreen = clean . home
 164  
 165  -- utilities
 166  
 167  newpos :: Float -> Float -> Point -> Point
 168  newpos dir d pos0 = pos0 G.+ diff
 169      where
 170          diff = d G.* unitVectorAtAngle a
 171          a = degToRad (90 - dir)
 172  
 173  spot :: Float -> Point -> Picture
 174  spot thc (x,y)
 175      = translate x y
 176      $ circleSolid (thc / 2)
 177  
 178  dispPict :: Picture -> IO ()
 179  dispPict pict = display FullScreen white pict
 180  
 181  thicLine :: Float -> Float -> Float -> Point -> Picture
 182  thicLine dis dir thc pos1 
 183      = spot thc pos1
 184      <> spot thc pos2
 185      <> translate x y (rotate dir $ rectangleSolid thc dis)
 186      where
 187          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 188          pos2 = newpos dir dis pos1
 189  
 190  dispWorld :: World -> IO ()
 191  dispWorld world = maybe (dispPict blank) dispPict world.pict
Ok, no modules loaded.
2022-10-27 19:25:38.556301828
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-10-27 19:25:38.823300617
>>> dispWorld (fd 100 (lt 60 (fd 200 defaultWorld)))
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-11-17 18:48:19.413693167
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22      deriving (Eq, Show)
  23  
  24  data Wrap
  25      = Wrap
  26      | Window
  27      | Fence
  28      deriving (Eq, Show)
  29  
  30  defaultWorld :: World
  31  defaultWorld = World { instructions = defaultInstructions
  32                       , turtle = defaultTurtle 
  33                       , pict = Just defaultTurtle.selfimg
  34                       , wrap = Wrap
  35                       }
  36  
  37  data Turtle
  38      = Turtle
  39      { position :: Point
  40      , direction :: Float
  41      , pen :: Updown
  42      , thic :: Float
  43      , color :: Color
  44      , showme :: Bool
  45      , curimg :: Picture
  46      , selfimg :: Picture
  47      }
  48      deriving (Eq, Show)
  49  
  50  defaultTurtle :: Turtle
  51  defaultTurtle = Turtle
  52                { position = (0,0)
  53                , direction = initdir
  54                , pen = Down
  55                , thic = 10
  56                , color = black
  57                , showme = True
  58                , curimg = rotate initdir original
  59                , selfimg = original
  60                } 
  61                where
  62                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  63                  initdir = 90
  64  
  65  data Updown
  66      = Up
  67      | Down
  68      deriving (Eq, Show)
  69  
  70  --
  71  
  72  type Instruction = World -> World
  73  
  74  forward, fd :: Float -> Instruction
  75  forward d world = case world of
  76      World { turtle = turtle } 
  77          -> world { turtle = turtle { position = (x',y') 
  78                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  79                                     }
  80                   , pict = Just $ case turtle.pen of
  81                      Up   -> blank
  82                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  83                   }
  84              where
  85                  (x',y') = newpos turtle.direction d turtle.position
  86  
  87  fd = forward
  88  
  89  back, bk :: Float -> Instruction
  90  back = forward . negate
  91  
  92  bk = back
  93  
  94  left, lt :: Float -> Instruction
  95  left = right . negate
  96  
  97  lt = left
  98  
  99  right, rt :: Float -> Instruction 
 100  right dir world = case world of
 101      World { turtle = turtle } 
 102          -> world { turtle = turtle { direction = newdir 
 103                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 104                                     }
 105                   , pict = Just blank
 106                   }
 107              where
 108                  newdir = turtle.direction + dir
 109  
 110  rt = right
 111  
 112  setxy :: Float -> Float -> Instruction
 113  setxy x y world =  case world of
 114      World { turtle = turtle } 
 115          -> world { turtle = turtle { position = (x,y) 
 116                                     , curimg = translate x y turtle.selfimg
 117                                     }
 118                   , pict = Just $ case turtle.pen of
 119                      Up   -> blank
 120                      Down -> thicLine dist dir turtle.thic turtle.position
 121                   }
 122              where
 123                  vec = (x,y) G.- turtle.position
 124                  dist = magV vec
 125                  dir = radToDeg (angleVV (0,1) vec)
 126  
 127  setx :: Float -> Instruction
 128  setx x world = case world of
 129      World { turtle = turtle } 
 130          -> setxy x y world
 131          where
 132              (_,y) = turtle.position
 133  
 134  sety :: Float -> Instruction
 135  sety y world = case world of
 136      World { turtle = turtle } 
 137          -> setxy x y world
 138          where
 139              (x,_) = turtle.position
 140  
 141  setheading :: Float -> Instruction
 142  setheading h world = case world of
 143      World { turtle = turtle } 
 144          -> right (h-d) world
 145          where
 146              d = turtle.direction
 147  
 148  home :: Instruction
 149  home world = case world of
 150      World { turtle = turtle } 
 151          -> setheading 0 (setxy 0 0 world )
 152  
 153  arc :: Float -> Float -> Instruction
 154  arc t r world = case world of
 155      World { turtle = turtle }
 156          -> world { turtle = turtle { direction = turtle.direction + t 
 157                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 158                                     }
 159                   , pict = Just tarc 
 160                   }
 161              where
 162                  (x,y) = turtle.position
 163                  d = turtle.direction
 164                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 165  
 166  penup :: Instruction 
 167  penup world = case world of
 168      World { turtle = turtle }
 169          -> world { turtle = turtle { pen = Up }
 170                   }
 171  
 172  pendown :: Instruction 
 173  pendown world = case world of
 174      World { turtle = turtle }
 175          -> world { turtle = turtle { pen = Down }
 176                   }
 177  
 178  clean :: Instruction
 179  clean world = world { pict = Nothing }
 180  
 181  clearscreen :: Instruction
 182  clearscreen = clean . home
 183  
 184  showturtle :: Instruction
 185  showturtle world = case world of
 186      World { turtle = turtle }
 187          -> world { turtle = turtle { showme = True }}
 188  
 189  hideturtle :: Instruction
 190  hideturtle world = case world of
 191      World { turtle = turtle }
 192          -> world { turtle = turtle { showme = False }}
 193  
 194  wrapI :: Instruction
 195  wrapI world = world { wrap = Wrap }
 196  
 197  windowI :: Instruction
 198  windowI world = world { wrap = Window }
 199  
 200  fenceI :: Instruction
 201  fenceI world = world { wrap = Fence }
 202  -- utilities
 203  
 204  newpos :: Float -> Float -> Point -> Point
 205  newpos dir d pos0 = pos0 G.+ diff
 206      where
 207          diff = d G.* unitVectorAtAngle a
 208          a = degToRad (90 - dir)
 209  
 210  spot :: Float -> Point -> Picture
 211  spot thc (x,y)
 212      = translate x y
 213      $ circleSolid (thc / 2)
 214  
 215  dispPict :: Picture -> IO ()
 216  dispPict pict = display FullScreen white pict
 217  
 218  thicLine :: Float -> Float -> Float -> Point -> Picture
 219  thicLine dis dir thc pos1 
 220      = spot thc pos1
 221      <> spot thc pos2
 222      <> translate x y (rotate dir $ rectangleSolid thc dis)
 223      where
 224          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 225          pos2 = newpos dir dis pos1
 226  
 227  dispWorld :: World -> IO ()
 228  dispWorld world = maybe (dispPict blank) dispPict world.pict
 229  
 230  --
 231  
 232  accumWorld :: [World] -> [Picture]
 233  accumWorld = scanl accum blank
 234  
 235  accum :: Picture -> World -> Picture
 236  accum pict world = case world of
 237      World { turtle = turtle 
 238            , pict = pict
 239            , wrap = wrap
 240            } -> case pict of
 241              Nothing -> blank
 242              Just pic -> pict <> pic
 243  
 244  --
 245  
 246  eval :: World -> [World]
 247  eval world = world : rests
 248      where 
 249          rests
 250              | final world = []
 251              | otherwise = eval (step world)
 252  
 253  final :: World -> Bool
 254  final world = null world.instructions
 255  
 256  step :: World -> World
 257  step world = world' { instructions = tail world.instructions }
 258      where
 259          world' = head world.instructions world
 260  
 261  defaultInstructions :: [Instruction]
 262  defaultInstructions 
 263      = [ fd 200
 264        , lt 90
 265        , fd 190
 266        , lt 90
 267        , fd 180
 268        , lt 90
 269        , fd 170
 270        , lt 90
 271        , fd 160
 272        ]
 273  
Ok, no modules loaded.
2022-11-17 18:48:34.822555162
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:22:15: error:
    • No instance for (Eq (World -> World))
        arising from the first field of ‘World’ (type ‘[Instruction]’)
        (maybe you haven't applied a function to enough arguments?)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Eq World)
   |
22 |     deriving (Eq, Show)
   |               ^^

src/World.hs:22:19: error:
    • No instance for (Show (World -> World))
        arising from the first field of ‘World’ (type ‘[Instruction]’)
        (maybe you haven't applied a function to enough arguments?)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Show World)
   |
22 |     deriving (Eq, Show)
   |                   ^^^^
Failed, no modules loaded.
2022-11-17 18:48:35.001517723
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22      deriving (Eq)
  23  
  24  data Wrap
  25      = Wrap
  26      | Window
  27      | Fence
  28      deriving (Eq, Show)
  29  
  30  defaultWorld :: World
  31  defaultWorld = World { instructions = defaultInstructions
  32                       , turtle = defaultTurtle 
  33                       , pict = Just defaultTurtle.selfimg
  34                       , wrap = Wrap
  35                       }
  36  
  37  data Turtle
  38      = Turtle
  39      { position :: Point
  40      , direction :: Float
  41      , pen :: Updown
  42      , thic :: Float
  43      , color :: Color
  44      , showme :: Bool
  45      , curimg :: Picture
  46      , selfimg :: Picture
  47      }
  48      deriving (Eq, Show)
  49  
  50  defaultTurtle :: Turtle
  51  defaultTurtle = Turtle
  52                { position = (0,0)
  53                , direction = initdir
  54                , pen = Down
  55                , thic = 10
  56                , color = black
  57                , showme = True
  58                , curimg = rotate initdir original
  59                , selfimg = original
  60                } 
  61                where
  62                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  63                  initdir = 90
  64  
  65  data Updown
  66      = Up
  67      | Down
  68      deriving (Eq, Show)
  69  
  70  --
  71  
  72  type Instruction = World -> World
  73  
  74  forward, fd :: Float -> Instruction
  75  forward d world = case world of
  76      World { turtle = turtle } 
  77          -> world { turtle = turtle { position = (x',y') 
  78                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  79                                     }
  80                   , pict = Just $ case turtle.pen of
  81                      Up   -> blank
  82                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  83                   }
  84              where
  85                  (x',y') = newpos turtle.direction d turtle.position
  86  
  87  fd = forward
  88  
  89  back, bk :: Float -> Instruction
  90  back = forward . negate
  91  
  92  bk = back
  93  
  94  left, lt :: Float -> Instruction
  95  left = right . negate
  96  
  97  lt = left
  98  
  99  right, rt :: Float -> Instruction 
 100  right dir world = case world of
 101      World { turtle = turtle } 
 102          -> world { turtle = turtle { direction = newdir 
 103                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 104                                     }
 105                   , pict = Just blank
 106                   }
 107              where
 108                  newdir = turtle.direction + dir
 109  
 110  rt = right
 111  
 112  setxy :: Float -> Float -> Instruction
 113  setxy x y world =  case world of
 114      World { turtle = turtle } 
 115          -> world { turtle = turtle { position = (x,y) 
 116                                     , curimg = translate x y turtle.selfimg
 117                                     }
 118                   , pict = Just $ case turtle.pen of
 119                      Up   -> blank
 120                      Down -> thicLine dist dir turtle.thic turtle.position
 121                   }
 122              where
 123                  vec = (x,y) G.- turtle.position
 124                  dist = magV vec
 125                  dir = radToDeg (angleVV (0,1) vec)
 126  
 127  setx :: Float -> Instruction
 128  setx x world = case world of
 129      World { turtle = turtle } 
 130          -> setxy x y world
 131          where
 132              (_,y) = turtle.position
 133  
 134  sety :: Float -> Instruction
 135  sety y world = case world of
 136      World { turtle = turtle } 
 137          -> setxy x y world
 138          where
 139              (x,_) = turtle.position
 140  
 141  setheading :: Float -> Instruction
 142  setheading h world = case world of
 143      World { turtle = turtle } 
 144          -> right (h-d) world
 145          where
 146              d = turtle.direction
 147  
 148  home :: Instruction
 149  home world = case world of
 150      World { turtle = turtle } 
 151          -> setheading 0 (setxy 0 0 world )
 152  
 153  arc :: Float -> Float -> Instruction
 154  arc t r world = case world of
 155      World { turtle = turtle }
 156          -> world { turtle = turtle { direction = turtle.direction + t 
 157                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 158                                     }
 159                   , pict = Just tarc 
 160                   }
 161              where
 162                  (x,y) = turtle.position
 163                  d = turtle.direction
 164                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 165  
 166  penup :: Instruction 
 167  penup world = case world of
 168      World { turtle = turtle }
 169          -> world { turtle = turtle { pen = Up }
 170                   }
 171  
 172  pendown :: Instruction 
 173  pendown world = case world of
 174      World { turtle = turtle }
 175          -> world { turtle = turtle { pen = Down }
 176                   }
 177  
 178  clean :: Instruction
 179  clean world = world { pict = Nothing }
 180  
 181  clearscreen :: Instruction
 182  clearscreen = clean . home
 183  
 184  showturtle :: Instruction
 185  showturtle world = case world of
 186      World { turtle = turtle }
 187          -> world { turtle = turtle { showme = True }}
 188  
 189  hideturtle :: Instruction
 190  hideturtle world = case world of
 191      World { turtle = turtle }
 192          -> world { turtle = turtle { showme = False }}
 193  
 194  wrapI :: Instruction
 195  wrapI world = world { wrap = Wrap }
 196  
 197  windowI :: Instruction
 198  windowI world = world { wrap = Window }
 199  
 200  fenceI :: Instruction
 201  fenceI world = world { wrap = Fence }
 202  -- utilities
 203  
 204  newpos :: Float -> Float -> Point -> Point
 205  newpos dir d pos0 = pos0 G.+ diff
 206      where
 207          diff = d G.* unitVectorAtAngle a
 208          a = degToRad (90 - dir)
 209  
 210  spot :: Float -> Point -> Picture
 211  spot thc (x,y)
 212      = translate x y
 213      $ circleSolid (thc / 2)
 214  
 215  dispPict :: Picture -> IO ()
 216  dispPict pict = display FullScreen white pict
 217  
 218  thicLine :: Float -> Float -> Float -> Point -> Picture
 219  thicLine dis dir thc pos1 
 220      = spot thc pos1
 221      <> spot thc pos2
 222      <> translate x y (rotate dir $ rectangleSolid thc dis)
 223      where
 224          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 225          pos2 = newpos dir dis pos1
 226  
 227  dispWorld :: World -> IO ()
 228  dispWorld world = maybe (dispPict blank) dispPict world.pict
 229  
 230  --
 231  
 232  accumWorld :: [World] -> [Picture]
 233  accumWorld = scanl accum blank
 234  
 235  accum :: Picture -> World -> Picture
 236  accum pict world = case world of
 237      World { turtle = turtle 
 238            , pict = pict
 239            , wrap = wrap
 240            } -> case pict of
 241              Nothing -> blank
 242              Just pic -> pict <> pic
 243  
 244  --
 245  
 246  eval :: World -> [World]
 247  eval world = world : rests
 248      where 
 249          rests
 250              | final world = []
 251              | otherwise = eval (step world)
 252  
 253  final :: World -> Bool
 254  final world = null world.instructions
 255  
 256  step :: World -> World
 257  step world = world' { instructions = tail world.instructions }
 258      where
 259          world' = head world.instructions world
 260  
 261  defaultInstructions :: [Instruction]
 262  defaultInstructions 
 263      = [ fd 200
 264        , lt 90
 265        , fd 190
 266        , lt 90
 267        , fd 180
 268        , lt 90
 269        , fd 170
 270        , lt 90
 271        , fd 160
 272        ]
 273  
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:22:15: error:
    • No instance for (Eq (World -> World))
        arising from the first field of ‘World’ (type ‘[Instruction]’)
        (maybe you haven't applied a function to enough arguments?)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Eq World)
   |
22 |     deriving (Eq)
   |               ^^
Failed, no modules loaded.
2022-11-17 18:49:01.289920541
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:22:15: error:
    • No instance for (Eq (World -> World))
        arising from the first field of ‘World’ (type ‘[Instruction]’)
        (maybe you haven't applied a function to enough arguments?)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Eq World)
   |
22 |     deriving (Eq)
   |               ^^
Failed, no modules loaded.
2022-11-17 18:49:01.377194631
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just defaultTurtle.selfimg
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle 
 237            , pict = pict
 238            , wrap = wrap
 239            } -> case pict of
 240              Nothing -> blank
 241              Just pic -> pict <> pic
 242  
 243  --
 244  
 245  eval :: World -> [World]
 246  eval world = world : rests
 247      where 
 248          rests
 249              | final world = []
 250              | otherwise = eval (step world)
 251  
 252  final :: World -> Bool
 253  final world = null world.instructions
 254  
 255  step :: World -> World
 256  step world = world' { instructions = tail world.instructions }
 257      where
 258          world' = head world.instructions world
 259  
 260  defaultInstructions :: [Instruction]
 261  defaultInstructions 
 262      = [ fd 200
 263        , lt 90
 264        , fd 190
 265        , lt 90
 266        , fd 180
 267        , lt 90
 268        , fd 170
 269        , lt 90
 270        , fd 160
 271        ]
 272  
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:241:25: error:
    • Couldn't match expected type ‘Picture’
                  with actual type ‘Maybe Picture’
    • In the first argument of ‘(<>)’, namely ‘pict’
      In the expression: pict <> pic
      In a case alternative: Just pic -> pict <> pic
    |
241 |             Just pic -> pict <> pic
    |                         ^^^^
Failed, no modules loaded.
2022-11-17 18:49:17.912880655
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:241:25: error:
    • Couldn't match expected type ‘Picture’
                  with actual type ‘Maybe Picture’
    • In the first argument of ‘(<>)’, namely ‘pict’
      In the expression: pict <> pic
      In a case alternative: Just pic -> pict <> pic
    |
241 |             Just pic -> pict <> pic
    |                         ^^^^
Failed, no modules loaded.
2022-11-17 18:49:17.952016887
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just defaultTurtle.selfimg
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle 
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> pict <> pic
 242  
 243  --
 244  
 245  eval :: World -> [World]
 246  eval world = world : rests
 247      where 
 248          rests
 249              | final world = []
 250              | otherwise = eval (step world)
 251  
 252  final :: World -> Bool
 253  final world = null world.instructions
 254  
 255  step :: World -> World
 256  step world = world' { instructions = tail world.instructions }
 257      where
 258          world' = head world.instructions world
 259  
 260  defaultInstructions :: [Instruction]
 261  defaultInstructions 
 262      = [ fd 200
 263        , lt 90
 264        , fd 190
 265        , lt 90
 266        , fd 180
 267        , lt 90
 268        , fd 170
 269        , lt 90
 270        , fd 160
 271        ]
 272  
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-11-17 18:50:05.514895607
>>> displayWorld (last (eval defaultWorld))

<interactive>:8:1: error:
    • Variable not in scope: displayWorld :: World -> t
    • Perhaps you meant ‘dispWorld’ (line 227)
2022-11-17 18:51:19.769266668
>>> dispWorld (last (eval defaultWorld))
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-11-17 18:53:10.312818717
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just defaultTurtle.selfimg
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle 
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> pict <> pic
 242  
 243  --
 244  
 245  eval :: World -> [World]
 246  eval world = world : rests
 247      where 
 248          rests
 249              | final world = []
 250              | otherwise = eval (step world)
 251  
 252  final :: World -> Bool
 253  final world = null world.instructions
 254  
 255  step :: World -> World
 256  step world = world' { instructions = tail world.instructions }
 257      where
 258          world' = head world.instructions world
 259  
 260  defaultInstructions :: [Instruction]
 261  defaultInstructions 
 262      = [ fd 200
 263        , lt 90
 264        , fd 190
 265        , lt 90
 266        , fd 180
 267        , lt 90
 268        , fd 170
 269        , lt 90
 270        , fd 160
 271        ]
 272  
Ok, no modules loaded.
2022-11-17 18:53:22.197947472
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-11-17 18:53:22.501002961
>>> dispWorld (last (accumWorld (eval defaultWorld)))

<interactive>:3:18: error:
    • Couldn't match type ‘Picture’ with ‘World’
      Expected: [World]
        Actual: [Picture]
    • In the first argument of ‘last’, namely
        ‘(accumWorld (eval defaultWorld))’
      In the first argument of ‘dispWorld’, namely
        ‘(last (accumWorld (eval defaultWorld)))’
      In the expression:
        dispWorld (last (accumWorld (eval defaultWorld)))
2022-11-17 18:53:59.061642688
>>> dispPict (last (accumWorld (eval defaultWorld)))
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-11-17 19:22:42.219911554
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just (Pictures [defaultTurtle.curimg, blank])
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle { curimg = curimg }
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> case pict of
 242                  Pictures [self, pics] -> Pictures [curimg, pics <> pic]
 243  
 244  --
 245  
 246  eval :: World -> [World]
 247  eval world = world : rests
 248      where 
 249          rests
 250              | final world = []
 251              | otherwise = eval (step world)
 252  
 253  final :: World -> Bool
 254  final world = null world.instructions
 255  
 256  step :: World -> World
 257  step world = world' { instructions = tail world.instructions }
 258      where
 259          world' = head world.instructions world
 260  
 261  defaultInstructions :: [Instruction]
 262  defaultInstructions 
 263      = [ fd 200
 264        , lt 90
 265        , fd 190
 266        , lt 90
 267        , fd 180
 268        , lt 90
 269        , fd 170
 270        , lt 90
 271        , fd 160
 272        ]
 273  
Ok, no modules loaded.
2022-11-17 19:22:54.38855037
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )

src/World.hs:236:22: error: Not a record constructor: turtle
    |
236 |     World { turtle = turtle { curimg = curimg }
    |                      ^^^^^^
Failed, no modules loaded.
2022-11-17 19:22:54.491686894
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just (Pictures [defaultTurtle.curimg, blank])
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> case pict of
 242                  Pictures [self, pics] -> Pictures [turtle.curimg, pics <> pic]
 243  
 244  --
 245  
 246  eval :: World -> [World]
 247  eval world = world : rests
 248      where 
 249          rests
 250              | final world = []
 251              | otherwise = eval (step world)
 252  
 253  final :: World -> Bool
 254  final world = null world.instructions
 255  
 256  step :: World -> World
 257  step world = world' { instructions = tail world.instructions }
 258      where
 259          world' = head world.instructions world
 260  
 261  defaultInstructions :: [Instruction]
 262  defaultInstructions 
 263      = [ fd 200
 264        , lt 90
 265        , fd 190
 266        , lt 90
 267        , fd 180
 268        , lt 90
 269        , fd 170
 270        , lt 90
 271        , fd 160
 272        ]
 273  
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-11-17 19:23:53.498269964
>>> :e
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just (Pictures [defaultTurtle.curimg, blank])
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> case pict of
 242                  Pictures [_, pics] -> Pictures [turtle.curimg, pics <> pic]
 243  
 244  --
 245  
 246  eval :: World -> [World]
 247  eval world = world : rests
 248      where 
 249          rests
 250              | final world = []
 251              | otherwise = eval (step world)
 252  
 253  final :: World -> Bool
 254  final world = null world.instructions
 255  
 256  step :: World -> World
 257  step world = world' { instructions = tail world.instructions }
 258      where
 259          world' = head world.instructions world
 260  
 261  defaultInstructions :: [Instruction]
 262  defaultInstructions 
 263      = [ fd 200
 264        , lt 90
 265        , fd 190
 266        , lt 90
 267        , fd 180
 268        , lt 90
 269        , fd 170
 270        , lt 90
 271        , fd 160
 272        ]
 273  
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-11-17 19:24:22.250577879
>>> dispPict (last (accumWorld (eval defaultWorld)))
<interactive>: src/World.hs:(241,25)-(242,75): Non-exhaustive patterns in case

<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-11-17 19:25:07.801827863
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just (Pictures [defaultTurtle.curimg, blank])
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> case pict of
 242                  Pictures [_, pics] -> Pictures [turtle.curimg, pics <> pic]
 243  
 244  --
 245  
 246  eval :: World -> [World]
 247  eval world = world : rests
 248      where 
 249          rests
 250              | final world = []
 251              | otherwise = eval (step world)
 252  
 253  final :: World -> Bool
 254  final world = null world.instructions
 255  
 256  step :: World -> World
 257  step world = world' { instructions = tail world.instructions }
 258      where
 259          world' = head world.instructions world
 260  
 261  defaultInstructions :: [Instruction]
 262  defaultInstructions 
 263      = [ fd 200
 264        , lt 90
 265        , fd 190
 266        , lt 90
 267        , fd 180
 268        , lt 90
 269        , fd 170
 270        , lt 90
 271        , fd 160
 272        ]
 273  
Ok, no modules loaded.
2022-11-17 19:25:12.555525094
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-11-17 19:25:12.887887827
>>> dispPict (last (accumWorld (eval defaultWorld)))
<interactive>: src/World.hs:(241,25)-(242,75): Non-exhaustive patterns in case

<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-11-17 19:26:51.392838352
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just (Pictures [defaultTurtle.curimg, blank])
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> case pict of
 242                  Pictures [_, pics] -> Pictures [turtle.curimg, pics <> pic]
 243  
 244  --
 245  
 246  eval :: World -> [World]
 247  eval world = world : rests
 248      where 
 249          rests
 250              | final world = []
 251              | otherwise = eval (step world)
 252  
 253  final :: World -> Bool
 254  final world = null world.instructions
 255  
 256  step :: World -> World
 257  step world = world' { instructions = tail world.instructions }
 258      where
 259          world' = head world.instructions world
 260  
 261  defaultInstructions :: [Instruction]
 262  defaultInstructions 
 263      = [ fd 200
 264        , lt 90
 265        , fd 190
 266        , lt 90
 267        , fd 180
 268        , lt 90
 269        , fd 170
 270        , lt 90
 271        , fd 160
 272        ]
 273  
Ok, no modules loaded.
2022-11-17 19:26:53.842068594
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-11-17 19:26:54.167776934
>>> dispPict (last (accumWorld (eval defaultWorld)))
<interactive>: src/World.hs:(241,25)-(242,75): Non-exhaustive patterns in case

<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
free(): corrupted unsorted chunks
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-11-17 19:28:42.362431741
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just (Pictures [defaultTurtle.curimg, blank])
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum blank
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> case pict of
 242                  Pictures [_, pics] -> Pictures [turtle.curimg, pics <> pic]
 243                  _ -> error $ show pict
 244  
 245  --
 246  
 247  eval :: World -> [World]
 248  eval world = world : rests
 249      where 
 250          rests
 251              | final world = []
 252              | otherwise = eval (step world)
 253  
 254  final :: World -> Bool
 255  final world = null world.instructions
 256  
 257  step :: World -> World
 258  step world = world' { instructions = tail world.instructions }
 259      where
 260          world' = head world.instructions world
 261  
 262  defaultInstructions :: [Instruction]
 263  defaultInstructions 
 264      = [ fd 200
 265        , lt 90
 266        , fd 190
 267        , lt 90
 268        , fd 180
 269        , lt 90
 270        , fd 170
 271        , lt 90
 272        , fd 160
 273        ]
 274  
Ok, no modules loaded.
2022-11-17 19:28:46.02215563
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-11-17 19:28:46.353689148
>>> dispPict (last (accumWorld (eval defaultWorld)))
<interactive>: Blank
CallStack (from HasCallStack):
  error, called at src/World.hs:243:22 in main:World
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-11-17 19:30:28.183452641
>>> :e src/World.hs
   1  {-# LANGUAGE DuplicateRecordFields #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE OverloadedRecordDot #-}
   4  module World where
   5  
   6  import Data.Bool
   7  import Graphics.Gloss
   8  import Graphics.Gloss.Data.Color
   9  import qualified Graphics.Gloss.Data.Picture as G
  10  import Graphics.Gloss.Data.Point
  11  import qualified Graphics.Gloss.Data.Point.Arithmetic as G
  12  import Graphics.Gloss.Data.Vector
  13  import Graphics.Gloss.Geometry.Angle
  14  
  15  data World
  16      = World
  17      { instructions :: [Instruction]
  18      , turtle :: Turtle
  19      , pict   :: Maybe Picture 
  20      , wrap   :: Wrap
  21      }
  22  
  23  data Wrap
  24      = Wrap
  25      | Window
  26      | Fence
  27      deriving (Eq, Show)
  28  
  29  defaultWorld :: World
  30  defaultWorld = World { instructions = defaultInstructions
  31                       , turtle = defaultTurtle 
  32                       , pict = Just (Pictures [defaultTurtle.curimg, blank])
  33                       , wrap = Wrap
  34                       }
  35  
  36  data Turtle
  37      = Turtle
  38      { position :: Point
  39      , direction :: Float
  40      , pen :: Updown
  41      , thic :: Float
  42      , color :: Color
  43      , showme :: Bool
  44      , curimg :: Picture
  45      , selfimg :: Picture
  46      }
  47      deriving (Eq, Show)
  48  
  49  defaultTurtle :: Turtle
  50  defaultTurtle = Turtle
  51                { position = (0,0)
  52                , direction = initdir
  53                , pen = Down
  54                , thic = 10
  55                , color = black
  56                , showme = True
  57                , curimg = rotate initdir original
  58                , selfimg = original
  59                } 
  60                where
  61                  original =  lineLoop [(-10,-10),(-10,10),(10,10),(10,-10),(-10,-10),(0,10),(10,-10)]
  62                  initdir = 90
  63  
  64  data Updown
  65      = Up
  66      | Down
  67      deriving (Eq, Show)
  68  
  69  --
  70  
  71  type Instruction = World -> World
  72  
  73  forward, fd :: Float -> Instruction
  74  forward d world = case world of
  75      World { turtle = turtle } 
  76          -> world { turtle = turtle { position = (x',y') 
  77                                     , curimg = translate x' y' (rotate turtle.direction turtle.selfimg)
  78                                     }
  79                   , pict = Just $ case turtle.pen of
  80                      Up   -> blank
  81                      Down -> thicLine d turtle.direction turtle.thic turtle.position
  82                   }
  83              where
  84                  (x',y') = newpos turtle.direction d turtle.position
  85  
  86  fd = forward
  87  
  88  back, bk :: Float -> Instruction
  89  back = forward . negate
  90  
  91  bk = back
  92  
  93  left, lt :: Float -> Instruction
  94  left = right . negate
  95  
  96  lt = left
  97  
  98  right, rt :: Float -> Instruction 
  99  right dir world = case world of
 100      World { turtle = turtle } 
 101          -> world { turtle = turtle { direction = newdir 
 102                                     , curimg = uncurry translate turtle.position (rotate newdir turtle.selfimg)
 103                                     }
 104                   , pict = Just blank
 105                   }
 106              where
 107                  newdir = turtle.direction + dir
 108  
 109  rt = right
 110  
 111  setxy :: Float -> Float -> Instruction
 112  setxy x y world =  case world of
 113      World { turtle = turtle } 
 114          -> world { turtle = turtle { position = (x,y) 
 115                                     , curimg = translate x y turtle.selfimg
 116                                     }
 117                   , pict = Just $ case turtle.pen of
 118                      Up   -> blank
 119                      Down -> thicLine dist dir turtle.thic turtle.position
 120                   }
 121              where
 122                  vec = (x,y) G.- turtle.position
 123                  dist = magV vec
 124                  dir = radToDeg (angleVV (0,1) vec)
 125  
 126  setx :: Float -> Instruction
 127  setx x world = case world of
 128      World { turtle = turtle } 
 129          -> setxy x y world
 130          where
 131              (_,y) = turtle.position
 132  
 133  sety :: Float -> Instruction
 134  sety y world = case world of
 135      World { turtle = turtle } 
 136          -> setxy x y world
 137          where
 138              (x,_) = turtle.position
 139  
 140  setheading :: Float -> Instruction
 141  setheading h world = case world of
 142      World { turtle = turtle } 
 143          -> right (h-d) world
 144          where
 145              d = turtle.direction
 146  
 147  home :: Instruction
 148  home world = case world of
 149      World { turtle = turtle } 
 150          -> setheading 0 (setxy 0 0 world )
 151  
 152  arc :: Float -> Float -> Instruction
 153  arc t r world = case world of
 154      World { turtle = turtle }
 155          -> world { turtle = turtle { direction = turtle.direction + t 
 156                                     , curimg = translate x y $ rotate (d+t) turtle.selfimg
 157                                     }
 158                   , pict = Just tarc 
 159                   }
 160              where
 161                  (x,y) = turtle.position
 162                  d = turtle.direction
 163                  tarc = translate x y $ rotate d $ thickArc 0 t r turtle.thic
 164  
 165  penup :: Instruction 
 166  penup world = case world of
 167      World { turtle = turtle }
 168          -> world { turtle = turtle { pen = Up }
 169                   }
 170  
 171  pendown :: Instruction 
 172  pendown world = case world of
 173      World { turtle = turtle }
 174          -> world { turtle = turtle { pen = Down }
 175                   }
 176  
 177  clean :: Instruction
 178  clean world = world { pict = Nothing }
 179  
 180  clearscreen :: Instruction
 181  clearscreen = clean . home
 182  
 183  showturtle :: Instruction
 184  showturtle world = case world of
 185      World { turtle = turtle }
 186          -> world { turtle = turtle { showme = True }}
 187  
 188  hideturtle :: Instruction
 189  hideturtle world = case world of
 190      World { turtle = turtle }
 191          -> world { turtle = turtle { showme = False }}
 192  
 193  wrapI :: Instruction
 194  wrapI world = world { wrap = Wrap }
 195  
 196  windowI :: Instruction
 197  windowI world = world { wrap = Window }
 198  
 199  fenceI :: Instruction
 200  fenceI world = world { wrap = Fence }
 201  -- utilities
 202  
 203  newpos :: Float -> Float -> Point -> Point
 204  newpos dir d pos0 = pos0 G.+ diff
 205      where
 206          diff = d G.* unitVectorAtAngle a
 207          a = degToRad (90 - dir)
 208  
 209  spot :: Float -> Point -> Picture
 210  spot thc (x,y)
 211      = translate x y
 212      $ circleSolid (thc / 2)
 213  
 214  dispPict :: Picture -> IO ()
 215  dispPict pict = display FullScreen white pict
 216  
 217  thicLine :: Float -> Float -> Float -> Point -> Picture
 218  thicLine dis dir thc pos1 
 219      = spot thc pos1
 220      <> spot thc pos2
 221      <> translate x y (rotate dir $ rectangleSolid thc dis)
 222      where
 223          (x,y) = 0.5 G.* (pos1 G.+ pos2)
 224          pos2 = newpos dir dis pos1
 225  
 226  dispWorld :: World -> IO ()
 227  dispWorld world = maybe (dispPict blank) dispPict world.pict
 228  
 229  --
 230  
 231  accumWorld :: [World] -> [Picture]
 232  accumWorld = scanl accum (Pictures [blank,blank])
 233  
 234  accum :: Picture -> World -> Picture
 235  accum pict world = case world of
 236      World { turtle = turtle
 237            , pict = mpict
 238            , wrap = wrap
 239            } -> case mpict of
 240              Nothing -> blank
 241              Just pic -> case pict of
 242                  Pictures [_, pics] -> Pictures [turtle.curimg, pics <> pic]
 243                  _ -> error $ show pict
 244  
 245  --
 246  
 247  eval :: World -> [World]
 248  eval world = world : rests
 249      where 
 250          rests
 251              | final world = []
 252              | otherwise = eval (step world)
 253  
 254  final :: World -> Bool
 255  final world = null world.instructions
 256  
 257  step :: World -> World
 258  step world = world' { instructions = tail world.instructions }
 259      where
 260          world' = head world.instructions world
 261  
 262  defaultInstructions :: [Instruction]
 263  defaultInstructions 
 264      = [ fd 200
 265        , lt 90
 266        , fd 190
 267        , lt 90
 268        , fd 180
 269        , lt 90
 270        , fd 170
 271        , lt 90
 272        , fd 160
 273        ]
 274  
Ok, no modules loaded.
2022-11-17 19:30:30.151507148
>>> :l src/World.hs
[1 of 1] Compiling World            ( src/World.hs, interpreted )
Ok, one module loaded.
2022-11-17 19:30:30.480570714
>>> dispPict (last (accumWorld (eval defaultWorld)))
<interactive>: interrupted
<interactive>: warning: too many hs_exit()s
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-12-01 18:04:35.467139018
>>> :e src/Syntax.hs
:l src/Syntax.hs
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq, Show)
  15  
  16  showExpr :: Expr -> String
  17  showExpr e = case e of
  18      ENum x -> show x
  19      EVar v -> v
  20      ERepeat e1 e2 -> intersparse " " ["repeat", showExpr e1, showExpr e2]
Ok, no modules loaded.
2022-12-01 18:53:45.589397109
>>> [1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:20:22: error:
    • Variable not in scope: intersparse :: t0 -> [String] -> String
    • Perhaps you meant ‘intersperse’ (imported from Data.List)
   |
20 |     ERepeat e1 e2 -> intersparse " " ["repeat", showExpr e1, showExpr e2]
   |                      ^^^^^^^^^^^
Failed, no modules loaded.
2022-12-01 18:53:45.950933394
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq, Show)
  15  
  16  showExpr :: Expr -> String
  17  showExpr e = case e of
  18      ENum x -> show x
  19      EVar v -> v
  20      ERepeat e1 e2 -> intersperse " " ["repeat", showExpr e1, showExpr e2]
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:20:49: error:
    • Couldn't match type ‘[Char]’ with ‘Char’
      Expected: Char
        Actual: String
    • In the expression: showExpr e1
      In the second argument of ‘intersperse’, namely
        ‘["repeat", showExpr e1, showExpr e2]’
      In the expression:
        intersperse " " ["repeat", showExpr e1, showExpr e2]
   |
20 |     ERepeat e1 e2 -> intersperse " " ["repeat", showExpr e1, showExpr e2]
   |                                                 ^^^^^^^^^^^

src/Syntax.hs:20:62: error:
    • Couldn't match type ‘[Char]’ with ‘Char’
      Expected: Char
        Actual: String
    • In the expression: showExpr e2
      In the second argument of ‘intersperse’, namely
        ‘["repeat", showExpr e1, showExpr e2]’
      In the expression:
        intersperse " " ["repeat", showExpr e1, showExpr e2]
   |
20 |     ERepeat e1 e2 -> intersperse " " ["repeat", showExpr e1, showExpr e2]
   |                                                              ^^^^^^^^^^^
Failed, no modules loaded.
2022-12-01 18:54:18.413439875
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq, Show)
  15  
  16  showExpr :: Expr -> String
  17  showExpr e = case e of
  18      ENum x -> show x
  19      EVar v -> v
  20      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-01 18:55:08.972622241
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq, Show)
  15  
  16  showExpr :: Expr -> String
  17  showExpr e = case e of
  18      ENum x -> show x
  19      EVar v -> v
  20      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  21      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"]
  22      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  23      EIf e1 e2 e3 -> intercalate " " (["if"] ++ showExpr e1 ++ ["then"] ++ showExpr e2 ++ ["else"] ++ showExpr e3)
  24      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  25  
  26  sample1 :: Expr
  27  sample1 = ERepeat 4 (EBlock [EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)])
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:22:5: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
22 |     EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
   |     ^
Failed, no modules loaded.
2022-12-01 19:09:52.630404851
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq, Show)
  15  
  16  showExpr :: Expr -> String
  17  showExpr e = case e of
  18      ENum x -> show x
  19      EVar v -> v
  20      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  21      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  22      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  23      EIf e1 e2 e3 -> intercalate " " (["if"] ++ showExpr e1 ++ ["then"] ++ showExpr e2 ++ ["else"] ++ showExpr e3)
  24      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  25  
  26  sample1 :: Expr
  27  sample1 = ERepeat 4 (EBlock [EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)])
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:23:48: error:
    • Couldn't match type ‘Char’ with ‘[Char]’
      Expected: [[Char]]
        Actual: String
    • In the first argument of ‘(++)’, namely ‘showExpr e1’
      In the second argument of ‘(++)’, namely
        ‘showExpr e1 ++ ["then"] ++ showExpr e2 ++ ["else"] ++ showExpr e3’
      In the second argument of ‘intercalate’, namely
        ‘(["if"]
            ++
              showExpr e1 ++ ["then"] ++ showExpr e2 ++ ["else"] ++ showExpr e3)’
   |
23 |     EIf e1 e2 e3 -> intercalate " " (["if"] ++ showExpr e1 ++ ["then"] ++ showExpr e2 ++ ["else"] ++ showExpr e3)
   |                                                ^^^^^^^^^^^

src/Syntax.hs:23:75: error:
    • Couldn't match type ‘Char’ with ‘[Char]’
      Expected: [[Char]]
        Actual: String
    • In the first argument of ‘(++)’, namely ‘showExpr e2’
      In the second argument of ‘(++)’, namely
        ‘showExpr e2 ++ ["else"] ++ showExpr e3’
      In the second argument of ‘(++)’, namely
        ‘["then"] ++ showExpr e2 ++ ["else"] ++ showExpr e3’
   |
23 |     EIf e1 e2 e3 -> intercalate " " (["if"] ++ showExpr e1 ++ ["then"] ++ showExpr e2 ++ ["else"] ++ showExpr e3)
   |                                                                           ^^^^^^^^^^^

src/Syntax.hs:23:102: error:
    • Couldn't match type ‘Char’ with ‘[Char]’
      Expected: [[Char]]
        Actual: String
    • In the second argument of ‘(++)’, namely ‘showExpr e3’
      In the second argument of ‘(++)’, namely ‘["else"] ++ showExpr e3’
      In the second argument of ‘(++)’, namely
        ‘showExpr e2 ++ ["else"] ++ showExpr e3’
   |
23 |     EIf e1 e2 e3 -> intercalate " " (["if"] ++ showExpr e1 ++ ["then"] ++ showExpr e2 ++ ["else"] ++ showExpr e3)
   |                                                                                                      ^^^^^^^^^^^

src/Syntax.hs:27:46: error:
    • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
    • In the second argument of ‘EProcCall’, namely ‘(ENum 200)’
      In the expression: EProcCall "fd" (ENum 200)
      In the first argument of ‘EBlock’, namely
        ‘[EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)]’
   |
27 | sample1 = ERepeat 4 (EBlock [EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)])
   |                                              ^^^^^^^^

src/Syntax.hs:27:73: error:
    • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
    • In the second argument of ‘EProcCall’, namely ‘(ENum 90)’
      In the expression: EProcCall "lt" (ENum 90)
      In the first argument of ‘EBlock’, namely
        ‘[EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)]’
   |
27 | sample1 = ERepeat 4 (EBlock [EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)])
   |                                                                         ^^^^^^^
Failed, no modules loaded.
2022-12-01 19:10:24.672130175
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq, Show)
  15  
  16  showExpr :: Expr -> String
  17  showExpr e = case e of
  18      ENum x -> show x
  19      EVar v -> v
  20      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  21      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  22      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  23      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  24      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  25  
  26  sample1 :: Expr
  27  sample1 = ERepeat 4 (EBlock [EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)])
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:27:46: error:
    • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
    • In the second argument of ‘EProcCall’, namely ‘(ENum 200)’
      In the expression: EProcCall "fd" (ENum 200)
      In the first argument of ‘EBlock’, namely
        ‘[EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)]’
   |
27 | sample1 = ERepeat 4 (EBlock [EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)])
   |                                              ^^^^^^^^

src/Syntax.hs:27:73: error:
    • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
    • In the second argument of ‘EProcCall’, namely ‘(ENum 90)’
      In the expression: EProcCall "lt" (ENum 90)
      In the first argument of ‘EBlock’, namely
        ‘[EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)]’
   |
27 | sample1 = ERepeat 4 (EBlock [EProcCall "fd" (ENum 200), EProcCall "lt" (ENum 90)])
   |                                                                         ^^^^^^^
Failed, no modules loaded.
2022-12-01 19:13:52.15742694
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq, Show)
  15  
  16  showExpr :: Expr -> String
  17  showExpr e = case e of
  18      ENum x -> show x
  19      EVar v -> v
  20      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  21      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  22      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  23      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  24      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  25  
  26  sample1 :: Expr
  27  sample1 = ERepeat 4 (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:27:19: error:
    • No instance for (Num Expr) arising from the literal ‘4’
    • In the first argument of ‘ERepeat’, namely ‘4’
      In the expression:
        ERepeat
          4 (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
      In an equation for ‘sample1’:
          sample1
            = ERepeat
                4 (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
   |
27 | sample1 = ERepeat 4 (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
   |                   ^
Failed, no modules loaded.
2022-12-01 19:14:52.200061477
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq, Show)
  15  
  16  showExpr :: Expr -> String
  17  showExpr e = case e of
  18      ENum x -> show x
  19      EVar v -> v
  20      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  21      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  22      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  23      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  24      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  25  
  26  sample1 :: Expr
  27  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-01 19:15:40.959731346
>>> showExpr sample1
"repeat 4.0 begin fd 200.0 lt 90.0 end"
2022-12-01 19:15:58.526205786
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.List
   5  
   6  data Expr
   7      = ENum Float
   8      | EVar String
   9      | ERepeat Expr Expr
  10      | EBlock [Expr]
  11      | EWhen Expr Expr
  12      | EIf Expr Expr Expr
  13      | EProcCall String [Expr]
  14      deriving (Eq)
  15  
  16  instance Show Expr where
  17      show = showExpr
  18  
  19  showExpr :: Expr -> String
  20  showExpr e = case e of
  21      ENum x -> show x
  22      EVar v -> v
  23      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  24      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  25      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  26      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  27      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  28  
  29  sample1 :: Expr
  30  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-01 19:18:44.967558825
>>> sample1
repeat 4.0 begin fd 200.0 lt 90.0 end
2022-12-01 19:18:52.507741604
>>> :q
Leaving GHCi.
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-12-08 19:16:37.034599818
>>> :e src/Syntax.hs
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Bop Expr Expr
  17      | EProcDef String [String]
  18      deriving (Eq)
  19  
  20  isAtom :: Expr -> Bool
  21  isAtom (ENum _) = True
  22  isAtom (EVar _) = True
  23  isAtom _ = False
  24  
  25  instance Show Expr where
  26      show = showExpr
  27  
  28  showExpr :: Expr -> String
  29  showExpr e = case e of
  30      ENum x -> show x
  31      EVar v -> v
  32      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  33      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  34      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  35      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  36      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  37      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  38          where
  39              show' e | isAtom e = show e
  40                      | otherwise = "(" ++ show e ++ ")"
  41      EProcDef proc vs -> unwords (proc : vs)
  42  
  43  sample1 :: Expr
  44  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  45  
  46  data Bop
  47      = Add | Sub | Mul | Div deriving (Eq)
  48  
  49  instance Show Bop where
  50      show Add = "+" 
  51      show Sub = "-"
  52      show Mul = "*"
  53      show Div = "/"
  54  --
  55  
  56  instance Read Expr where
  57      readsPrec _ = readP_to_S userInputR
  58  
  59  userInputR :: ReadP Expr
  60  userInputR = exprR +++ procdefR
  61  
  62  procdefR :: ReadP Expr
  63  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  64  
  65  idenR :: ReadP String
  66  idenR = munch1 isLetter
  67  
  68  exprR :: ReadP Expr
  69  exprR = undefined
Ok, no modules loaded.
2022-12-08 19:16:57.400362435
>>> :l src/Syntax.hs
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-08 19:16:57.539433719
>>> read "proc hoge x y z" :: Expr
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:74:14 in base:GHC.Err
  undefined, called at src/Syntax.hs:69:9 in main:Syntax
2022-12-08 19:18:05.173812985
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Bop Expr Expr
  17      | EProcDef String [String]
  18      deriving (Eq)
  19  
  20  isAtom :: Expr -> Bool
  21  isAtom (ENum _) = True
  22  isAtom (EVar _) = True
  23  isAtom _ = False
  24  
  25  instance Show Expr where
  26      show = showExpr
  27  
  28  showExpr :: Expr -> String
  29  showExpr e = case e of
  30      ENum x -> show x
  31      EVar v -> v
  32      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  33      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  34      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  35      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  36      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  37      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  38          where
  39              show' e | isAtom e = show e
  40                      | otherwise = "(" ++ show e ++ ")"
  41      EProcDef proc vs -> unwords (proc : vs)
  42  
  43  sample1 :: Expr
  44  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  45  
  46  data Bop
  47      = Add | Sub | Mul | Div deriving (Eq)
  48  
  49  instance Show Bop where
  50      show Add = "+" 
  51      show Sub = "-"
  52      show Mul = "*"
  53      show Div = "/"
  54  --
  55  
  56  instance Read Expr where
  57      readsPrec _ = readP_to_S userInputR
  58  
  59  userInputR :: ReadP Expr
  60  userInputR = {- exprR +++ -} procdefR
  61  
  62  procdefR :: ReadP Expr
  63  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  64  
  65  idenR :: ReadP String
  66  idenR = munch1 isLetter
  67  
  68  exprR :: ReadP Expr
  69  exprR = undefined
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-08 19:19:03.474845028
>>> read "proc hoge x y z" :: Expr
*** Exception: Prelude.read: no parse
2022-12-08 19:19:07.262737669
>>> hogeR = readP_to_S idenR 
2022-12-08 19:21:08.227993185
>>> hogeR 0 "hoge"

<interactive>:7:1: error:
    • Couldn't match expected type: t0 -> t
                  with actual type: [(String, String)]
    • The function ‘hogeR’ is applied to two value arguments,
        but its type ‘String -> [(String, String)]’ has only one
      In the expression: hogeR 0 "hoge"
      In an equation for ‘it’: it = hogeR 0 "hoge"
    • Relevant bindings include it :: t (bound at <interactive>:7:1)
2022-12-08 19:22:10.764011687
>>> hogeR "hoge"
[("hoge","")]
2022-12-08 19:23:13.531774273
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Bop Expr Expr
  17      | EProcDef String [String]
  18      deriving (Eq)
  19  
  20  isAtom :: Expr -> Bool
  21  isAtom (ENum _) = True
  22  isAtom (EVar _) = True
  23  isAtom _ = False
  24  
  25  instance Show Expr where
  26      show = showExpr
  27  
  28  showExpr :: Expr -> String
  29  showExpr e = case e of
  30      ENum x -> show x
  31      EVar v -> v
  32      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  33      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  34      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  35      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  36      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  37      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  38          where
  39              show' e | isAtom e = show e
  40                      | otherwise = "(" ++ show e ++ ")"
  41      EProcDef proc vs -> unwords (proc : vs)
  42  
  43  sample1 :: Expr
  44  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  45  
  46  data Bop
  47      = Add | Sub | Mul | Div deriving (Eq)
  48  
  49  instance Show Bop where
  50      show Add = "+" 
  51      show Sub = "-"
  52      show Mul = "*"
  53      show Div = "/"
  54  --
  55  
  56  instance Read Expr where
  57      readsPrec _ = readP_to_S userInputR
  58  
  59  userInputR :: ReadP Expr
  60  userInputR = {- exprR +++ -} procdefR
  61  
  62  procdefR :: ReadP Expr
  63  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  64  
  65  idenR :: ReadP String
  66  idenR = skipSpaces *> munch1 isLetter
  67  
  68  exprR :: ReadP Expr
  69  exprR = undefined
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-08 19:24:34.233926354
>>> read "proc hoge x y z" :: Expr
hoge x y z
2022-12-08 19:24:43.349150296
>>> read "prec hoge x y z" :: Expr
*** Exception: Prelude.read: no parse
2022-12-08 19:25:16.970487973
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Bop Expr Expr
  17      | EProcDef String [String]
  18      deriving (Eq, Show)
  19  
  20  isAtom :: Expr -> Bool
  21  isAtom (ENum _) = True
  22  isAtom (EVar _) = True
  23  isAtom _ = False
  24  
  25  -- instance Show Expr where
  26  --     show = showExpr
  27  
  28  showExpr :: Expr -> String
  29  showExpr e = case e of
  30      ENum x -> show x
  31      EVar v -> v
  32      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  33      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  34      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  35      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  36      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  37      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  38          where
  39              show' e | isAtom e = show e
  40                      | otherwise = "(" ++ show e ++ ")"
  41      EProcDef proc vs -> unwords (proc : vs)
  42  
  43  sample1 :: Expr
  44  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  45  
  46  data Bop
  47      = Add | Sub | Mul | Div deriving (Eq)
  48  
  49  instance Show Bop where
  50      show Add = "+" 
  51      show Sub = "-"
  52      show Mul = "*"
  53      show Div = "/"
  54  --
  55  
  56  instance Read Expr where
  57      readsPrec _ = readP_to_S userInputR
  58  
  59  userInputR :: ReadP Expr
  60  userInputR = {- exprR +++ -} procdefR
  61  
  62  procdefR :: ReadP Expr
  63  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  64  
  65  idenR :: ReadP String
  66  idenR = skipSpaces *> munch1 isLetter
  67  
  68  exprR :: ReadP Expr
  69  exprR = undefined
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-08 19:28:09.589693523
>>> read "prec hoge x y z" :: Expr
*** Exception: Prelude.read: no parse
2022-12-08 19:28:20.559555857
>>> read "proc hoge x y z" :: Expr
EProcDef "hoge" ["x","y","z"]
2022-12-08 19:28:29.931751015
>>> :q
Leaving GHCi.
Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2022-12-22 18:49:30.440649953
>>> :e src/Syntax.hs
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Bop Expr Expr
  17      | EProcDef String [String]
  18      deriving (Eq, Show)
  19  
  20  isAtom :: Expr -> Bool
  21  isAtom (ENum _) = True
  22  isAtom (EVar _) = True
  23  isAtom _ = False
  24  
  25  -- instance Show Expr where
  26  --     show = showExpr
  27  
  28  showExpr :: Expr -> String
  29  showExpr e = case e of
  30      ENum x -> show x
  31      EVar v -> v
  32      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  33      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  34      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  35      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  36      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  37      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  38          where
  39              show' e | isAtom e = show e
  40                      | otherwise = "(" ++ show e ++ ")"
  41      EProcDef proc vs -> unwords (proc : vs)
  42  
  43  sample1 :: Expr
  44  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  45  
  46  data Bop
  47      = Add | Sub | Mul | Div deriving (Eq)
  48  
  49  instance Show Bop where
  50      show Add = "+" 
  51      show Sub = "-"
  52      show Mul = "*"
  53      show Div = "/"
  54  --
  55  
  56  instance Read Expr where
  57      readsPrec _ = readP_to_S userInputR
  58  
  59  userInputR :: ReadP Expr
  60  userInputR =  exprR +++ procdefR
  61  
  62  procdefR :: ReadP Expr
  63  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  64  
  65  idenR :: ReadP String
  66  idenR = skipSpaces *> munch1 isLetter
  67  
  68  exprR :: ReadP Expr
  69  exprR = callprocR
  70  
  71  callprocR :: ReadP Expr
  72  callprocR = EProcCall <$> idenR <*> many exprR
Ok, no modules loaded.
2022-12-22 18:49:49.853266088
>>> :l src/Syntax.hs
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-22 18:49:50.008675636
>>> read "fd 200" :: Expr
*** Exception: Prelude.read: no parse
2022-12-22 18:50:37.90178227
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  data Rop
  57      = Lt | Gt deriving (Eq)
  58  
  59  instance Show Rop where
  60      show Lt = "<"
  61      show Gt = ">"
  62  
  63  bopR :: ReadP Bop
  64  bopR = skipSpaces *> Lt <$ string "<"
  65      +++ skipSpaces *> Gt <$ string ">"
  66  
  67  --
  68  
  69  instance Read Expr where
  70      readsPrec _ = readP_to_S userInputR
  71  
  72  userInputR :: ReadP Expr
  73  userInputR =  exprR +++ procdefR
  74  
  75  procdefR :: ReadP Expr
  76  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  77  
  78  idenR :: ReadP String
  79  idenR = skipSpaces *> munch1 isLetter
  80  
  81  exprR :: ReadP Expr
  82  exprR = ECompare <$> arithexpr  
  83  
  84  callprocR :: ReadP Expr
  85  callprocR = EProcCall <$> idenR <*> many exprR
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:82:22: error:
    Variable not in scope: arithexpr :: ReadP Expr
   |
82 | exprR = ECompare <$> arithexpr  
   |                      ^^^^^^^^^
Failed, no modules loaded.
2022-12-22 19:10:16.240953387
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = skipSpaces *> (Add <$ string "+")
  58      +++ skipSpaces *> (Sub <$ string "-")
  59  
  60  multR :: ReadP Bop
  61  multR = skipSpaces *> (Mul <$ string "*")
  62      +++ skipSpaces *> (Div <$ string "/")
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = skipSpaces *> (Lt <$ string "<")
  73      +++ skipSpaces *> (Gt <$ string ">")
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  procdefR :: ReadP Expr
  84  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  85  
  86  idenR :: ReadP String
  87  idenR = skipSpaces *> munch1 isLetter
  88  
  89  exprR :: ReadP Expr
  90  exprR = ECompare <$> arithexprR <*> bopR <*> arithexprR
  91  
  92  arithexprR :: ReadP Expr
  93  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
  94  
  95  callprocR :: ReadP Expr
  96  callprocR = EProcCall <$> idenR <*> many exprR
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:90:37: error:
    • Variable not in scope: bopR :: ReadP Rop
    • Perhaps you meant ‘ropR’ (line 72)
   |
90 | exprR = ECompare <$> arithexprR <*> bopR <*> arithexprR
   |                                     ^^^^

src/Syntax.hs:93:25: error:
    Variable not in scope: multiveR :: ReadP Expr
   |
93 | arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
   |                         ^^^^^^^^

src/Syntax.hs:93:48: error:
    Variable not in scope: multiveR :: ReadP Expr
   |
93 | arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
   |                                                ^^^^^^^^
Failed, no modules loaded.
2022-12-22 19:22:51.043260099
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = skipSpaces *> (Add <$ string "+")
  58      +++ skipSpaces *> (Sub <$ string "-")
  59  
  60  multR :: ReadP Bop
  61  multR = skipSpaces *> (Mul <$ string "*")
  62      +++ skipSpaces *> (Div <$ string "/")
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = skipSpaces *> (Lt <$ string "<")
  73      +++ skipSpaces *> (Gt <$ string ">")
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  procdefR :: ReadP Expr
  84  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  85  
  86  idenR :: ReadP String
  87  idenR = skipSpaces *> munch1 isLetter
  88  
  89  exprR :: ReadP Expr
  90  exprR = ECompare <$> arithexprR <*> bopR <*> arithexprR
  91  
  92  arithexprR :: ReadP Expr
  93  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
  94  
  95  multiveR :: ReadP Expr
  96  multiveR = undefined
  97  
  98  callprocR :: ReadP Expr
  99  callprocR = EProcCall <$> idenR <*> many exprR
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:90:37: error:
    • Variable not in scope: bopR :: ReadP Rop
    • Perhaps you meant ‘ropR’ (line 72)
   |
90 | exprR = ECompare <$> arithexprR <*> bopR <*> arithexprR
   |                                     ^^^^
Failed, no modules loaded.
2022-12-22 19:23:48.190600424
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = skipSpaces *> (Add <$ string "+")
  58      +++ skipSpaces *> (Sub <$ string "-")
  59  
  60  multR :: ReadP Bop
  61  multR = skipSpaces *> (Mul <$ string "*")
  62      +++ skipSpaces *> (Div <$ string "/")
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = skipSpaces *> (Lt <$ string "<")
  73      +++ skipSpaces *> (Gt <$ string ">")
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  procdefR :: ReadP Expr
  84  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  85  
  86  idenR :: ReadP String
  87  idenR = skipSpaces *> munch1 isLetter
  88  
  89  exprR :: ReadP Expr
  90  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
  91  
  92  arithexprR :: ReadP Expr
  93  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
  94  
  95  multiveR :: ReadP Expr
  96  multiveR = undefined
  97  
  98  callprocR :: ReadP Expr
  99  callprocR = EProcCall <$> idenR <*> many exprR
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:38:39: error:
    • Couldn't match expected type ‘Expr’ with actual type ‘Bop’
    • In the first argument of ‘show'’, namely ‘e1’
      In the expression: show' e1
      In the first argument of ‘unwords’, namely
        ‘[show' e1, show op, show' e1]’
   |
38 |     EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
   |                                       ^^

src/Syntax.hs:38:58: error:
    • Couldn't match expected type ‘Expr’ with actual type ‘Bop’
    • In the first argument of ‘show'’, namely ‘e1’
      In the expression: show' e1
      In the first argument of ‘unwords’, namely
        ‘[show' e1, show op, show' e1]’
   |
38 |     EArith op e1 e2 -> unwords [show' e1, show op, show' e1]
   |                                                          ^^

src/Syntax.hs:58:9: error:
    • Couldn't match type ‘()’ with ‘Bop’
      Expected: ReadP Bop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Add <$ string "+") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Add <$ string "+") +++ skipSpaces’
   |
58 |     +++ skipSpaces *> (Sub <$ string "-")
   |         ^^^^^^^^^^

src/Syntax.hs:62:9: error:
    • Couldn't match type ‘()’ with ‘Bop’
      Expected: ReadP Bop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Mul <$ string "*") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Mul <$ string "*") +++ skipSpaces’
   |
62 |     +++ skipSpaces *> (Div <$ string "/")
   |         ^^^^^^^^^^

src/Syntax.hs:73:9: error:
    • Couldn't match type ‘()’ with ‘Rop’
      Expected: ReadP Rop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Lt <$ string "<") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Lt <$ string "<") +++ skipSpaces’
   |
73 |     +++ skipSpaces *> (Gt <$ string ">")
   |         ^^^^^^^^^^
Failed, no modules loaded.
2022-12-22 19:24:18.780210331
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = skipSpaces *> (Add <$ string "+")
  58      +++ skipSpaces *> (Sub <$ string "-")
  59  
  60  multR :: ReadP Bop
  61  multR = skipSpaces *> (Mul <$ string "*")
  62      +++ skipSpaces *> (Div <$ string "/")
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = skipSpaces *> (Lt <$ string "<")
  73      +++ skipSpaces *> (Gt <$ string ">")
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  procdefR :: ReadP Expr
  84  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  85  
  86  idenR :: ReadP String
  87  idenR = skipSpaces *> munch1 isLetter
  88  
  89  exprR :: ReadP Expr
  90  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
  91  
  92  arithexprR :: ReadP Expr
  93  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
  94  
  95  multiveR :: ReadP Expr
  96  multiveR = undefined
  97  
  98  callprocR :: ReadP Expr
  99  callprocR = EProcCall <$> idenR <*> many exprR
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:58:9: error:
    • Couldn't match type ‘()’ with ‘Bop’
      Expected: ReadP Bop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Add <$ string "+") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Add <$ string "+") +++ skipSpaces’
   |
58 |     +++ skipSpaces *> (Sub <$ string "-")
   |         ^^^^^^^^^^

src/Syntax.hs:62:9: error:
    • Couldn't match type ‘()’ with ‘Bop’
      Expected: ReadP Bop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Mul <$ string "*") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Mul <$ string "*") +++ skipSpaces’
   |
62 |     +++ skipSpaces *> (Div <$ string "/")
   |         ^^^^^^^^^^

src/Syntax.hs:73:9: error:
    • Couldn't match type ‘()’ with ‘Rop’
      Expected: ReadP Rop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Lt <$ string "<") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Lt <$ string "<") +++ skipSpaces’
   |
73 |     +++ skipSpaces *> (Gt <$ string ">")
   |         ^^^^^^^^^^
Failed, no modules loaded.
2022-12-22 19:26:07.233643433
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = (skipSpaces *> (Add <$ string "+"))
  58      +++ (skipSpaces *> (Sub <$ string "-"))
  59  
  60  multR :: ReadP Bop
  61  multR = skipSpaces *> (Mul <$ string "*")
  62      +++ skipSpaces *> (Div <$ string "/")
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = skipSpaces *> (Lt <$ string "<")
  73      +++ skipSpaces *> (Gt <$ string ">")
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  procdefR :: ReadP Expr
  84  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  85  
  86  idenR :: ReadP String
  87  idenR = skipSpaces *> munch1 isLetter
  88  
  89  exprR :: ReadP Expr
  90  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
  91  
  92  arithexprR :: ReadP Expr
  93  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
  94  
  95  multiveR :: ReadP Expr
  96  multiveR = undefined
  97  
  98  callprocR :: ReadP Expr
  99  callprocR = EProcCall <$> idenR <*> many exprR
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:62:9: error:
    • Couldn't match type ‘()’ with ‘Bop’
      Expected: ReadP Bop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Mul <$ string "*") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Mul <$ string "*") +++ skipSpaces’
   |
62 |     +++ skipSpaces *> (Div <$ string "/")
   |         ^^^^^^^^^^

src/Syntax.hs:73:9: error:
    • Couldn't match type ‘()’ with ‘Rop’
      Expected: ReadP Rop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Lt <$ string "<") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Lt <$ string "<") +++ skipSpaces’
   |
73 |     +++ skipSpaces *> (Gt <$ string ">")
   |         ^^^^^^^^^^
Failed, no modules loaded.
2022-12-22 19:28:06.005096254
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = (skipSpaces *> (Add <$ string "+"))
  58      +++ (skipSpaces *> (Sub <$ string "-"))
  59  
  60  multR :: ReadP Bop
  61  multR = (skipSpaces *> (Mul <$ string "*"))
  62      +++ (skipSpaces *> (Div <$ string "/"))
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = skipSpaces *> (Lt <$ string "<")
  73      +++ skipSpaces *> (Gt <$ string ">")
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  procdefR :: ReadP Expr
  84  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  85  
  86  idenR :: ReadP String
  87  idenR = skipSpaces *> munch1 isLetter
  88  
  89  exprR :: ReadP Expr
  90  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
  91  
  92  arithexprR :: ReadP Expr
  93  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
  94  
  95  multiveR :: ReadP Expr
  96  multiveR = undefined
  97  
  98  callprocR :: ReadP Expr
  99  callprocR = EProcCall <$> idenR <*> many exprR
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )

src/Syntax.hs:73:9: error:
    • Couldn't match type ‘()’ with ‘Rop’
      Expected: ReadP Rop
        Actual: ReadP ()
    • In the second argument of ‘(+++)’, namely ‘skipSpaces’
      In the second argument of ‘(*>)’, namely
        ‘(Lt <$ string "<") +++ skipSpaces’
      In the first argument of ‘(*>)’, namely
        ‘skipSpaces *> (Lt <$ string "<") +++ skipSpaces’
   |
73 |     +++ skipSpaces *> (Gt <$ string ">")
   |         ^^^^^^^^^^
Failed, no modules loaded.
2022-12-22 19:28:27.059761121
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = (skipSpaces *> (Add <$ string "+"))
  58      +++ (skipSpaces *> (Sub <$ string "-"))
  59  
  60  multR :: ReadP Bop
  61  multR = (skipSpaces *> (Mul <$ string "*"))
  62      +++ (skipSpaces *> (Div <$ string "/"))
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = (skipSpaces *> (Lt <$ string "<"))
  73      +++ (skipSpaces *> (Gt <$ string ">"))
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  procdefR :: ReadP Expr
  84  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  85  
  86  idenR :: ReadP String
  87  idenR = skipSpaces *> munch1 isLetter
  88  
  89  exprR :: ReadP Expr
  90  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
  91  
  92  arithexprR :: ReadP Expr
  93  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
  94  
  95  multiveR :: ReadP Expr
  96  multiveR = undefined
  97  
  98  callprocR :: ReadP Expr
  99  callprocR = EProcCall <$> idenR <*> many exprR
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2022-12-22 19:28:45.711568542
>>> Stack has not been tested with GHC versions above 9.0, and using 9.2.4, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2023-01-12 18:00:26.740829084
>>> :q
Leaving GHCi.
Stack has not been tested with GHC versions above 9.0, and using 9.2.5, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.5: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2023-01-12 18:28:39.05911131
>>> read (head (lines sample)) :: Expr

<interactive>:1:31: error:
    Not in scope: type constructor or class ‘Expr’
2023-01-12 18:29:31.229757957
>>> :e src/Syntax.hs
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = (skipSpaces *> (Add <$ string "+"))
  58      +++ (skipSpaces *> (Sub <$ string "-"))
  59  
  60  multR :: ReadP Bop
  61  multR = (skipSpaces *> (Mul <$ string "*"))
  62      +++ (skipSpaces *> (Div <$ string "/"))
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = (skipSpaces *> (Lt <$ string "<"))
  73      +++ (skipSpaces *> (Gt <$ string ">"))
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  sample = unlines
  84      ["proc tree :n"
  85      ,"if :n < 5 then stop"
  86      ,"fd(:n)"
  87      ,"lt(30) tree(product(:n,0.7))"
  88      ,"rt(60) tree(:n * 0.7)"
  89      ,"lt(30) bk(:n)"
  90      ,"end"
  91      ]
  92  
  93  {- |
  94  procdefR
  95  >>> read (head (lines sample)) :: Expr
  96  -}
  97  procdefR :: ReadP Expr
  98  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  99  
 100  idenR :: ReadP String
 101  idenR = skipSpaces *> munch1 isLetter
 102  
 103  exprR :: ReadP Expr
 104  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
 105  
 106  arithexprR :: ReadP Expr
 107  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
 108  
 109  multiveR :: ReadP Expr
 110  multiveR = undefined
 111  
 112  callprocR :: ReadP Expr
 113  callprocR = EProcCall <$> idenR <*> many exprR
 114  
Ok, no modules loaded.
2023-01-12 18:30:02.39489966
>>> :l src/Syntax.hs
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2023-01-12 18:30:02.570732763
>>> read (head (lines sample)) :: Expr
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:74:14 in base:GHC.Err
  undefined, called at src/Syntax.hs:110:12 in main:Syntax
2023-01-12 18:30:07.457733302
>>> Stack has not been tested with GHC versions above 9.0, and using 9.2.5, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.6.3.0 was found, this may fail
GHCi, version 9.2.5: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2023-01-12 18:38:48.858630906
>>> :e src/Syntax.hs
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = (skipSpaces *> (Add <$ string "+"))
  58      +++ (skipSpaces *> (Sub <$ string "-"))
  59  
  60  multR :: ReadP Bop
  61  multR = (skipSpaces *> (Mul <$ string "*"))
  62      +++ (skipSpaces *> (Div <$ string "/"))
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = (skipSpaces *> (Lt <$ string "<"))
  73      +++ (skipSpaces *> (Gt <$ string ">"))
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  sample = unlines
  84      ["proc tree n"
  85      ,"if n < 5 then stop"
  86      ,"fd(n)"
  87      ,"lt(30) tree(product(n,0.7))"
  88      ,"rt(60) tree(n * 0.7)"
  89      ,"lt(30) bk(n)"
  90      ,"end"
  91      ]
  92  
  93  {- |
  94  procdefR
  95  >>> read (head (lines sample)) :: Expr
  96  -}
  97  procdefR :: ReadP Expr
  98  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  99  
 100  idenR :: ReadP String
 101  idenR = skipSpaces *> munch1 isLetter
 102  
 103  exprR :: ReadP Expr
 104  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
 105  
 106  arithexprR :: ReadP Expr
 107  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
 108  
 109  multiveR :: ReadP Expr
 110  multiveR = undefined
 111  
 112  callprocR :: ReadP Expr
 113  callprocR = EProcCall <$> idenR <*> many exprR
 114  
Ok, no modules loaded.
2023-01-12 18:39:04.62282155
>>> :l src/Syntax.hs
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2023-01-12 18:39:04.841731583
>>> read (head (lines sample)) :: Expr
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:74:14 in base:GHC.Err
  undefined, called at src/Syntax.hs:110:12 in main:Syntax
2023-01-12 18:39:49.177640243
>>> :t readP_to_S procdefR 
readP_to_S procdefR :: ReadS Expr
2023-01-12 18:43:13.907275854
>>> :i ReadS
type ReadS :: * -> *
type ReadS a = String -> [(a, String)]
  	-- Defined in ‘Text.ParserCombinators.ReadP’
2023-01-12 18:43:37.758135226
>>> readP_to_S procdefR (head (lines sample))  
[(EProcDef "tree" ["n"],"")]
2023-01-12 18:44:39.218862336
>>> readP_to_S exprR (head (lines sample))  
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:74:14 in base:GHC.Err
  undefined, called at src/Syntax.hs:110:12 in main:Syntax
2023-01-12 18:49:13.252876711
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Text.ParserCombinators.ReadP
   7  
   8  data Expr
   9      = ENum Float
  10      | EVar String
  11      | ERepeat Expr Expr
  12      | EBlock [Expr]
  13      | EWhen Expr Expr
  14      | EIf Expr Expr Expr
  15      | EProcCall String [Expr]
  16      | EArith Expr Bop Expr
  17      | ECompare Expr Rop Expr
  18      | EProcDef String [String]
  19      deriving (Eq, Show)
  20  
  21  isAtom :: Expr -> Bool
  22  isAtom (ENum _) = True
  23  isAtom (EVar _) = True
  24  isAtom _ = False
  25  
  26  -- instance Show Expr where
  27  --     show = showExpr
  28  
  29  showExpr :: Expr -> String
  30  showExpr e = case e of
  31      ENum x -> show x
  32      EVar v -> v
  33      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  34      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  35      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  36      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  37      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  38      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  39          where
  40              show' e | isAtom e = show e
  41                      | otherwise = "(" ++ show e ++ ")"
  42      EProcDef proc vs -> unwords (proc : vs)
  43  
  44  sample1 :: Expr
  45  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  46  
  47  data Bop
  48      = Add | Sub | Mul | Div deriving (Eq)
  49  
  50  instance Show Bop where
  51      show Add = "+" 
  52      show Sub = "-"
  53      show Mul = "*"
  54      show Div = "/"
  55  
  56  plusR :: ReadP Bop
  57  plusR = (skipSpaces *> (Add <$ string "+"))
  58      +++ (skipSpaces *> (Sub <$ string "-"))
  59  
  60  multR :: ReadP Bop
  61  multR = (skipSpaces *> (Mul <$ string "*"))
  62      +++ (skipSpaces *> (Div <$ string "/"))
  63  
  64  data Rop
  65      = Lt | Gt deriving (Eq)
  66  
  67  instance Show Rop where
  68      show Lt = "<"
  69      show Gt = ">"
  70  
  71  ropR :: ReadP Rop
  72  ropR = (skipSpaces *> (Lt <$ string "<"))
  73      +++ (skipSpaces *> (Gt <$ string ">"))
  74  
  75  --
  76  
  77  instance Read Expr where
  78      readsPrec _ = readP_to_S userInputR
  79  
  80  userInputR :: ReadP Expr
  81  userInputR =  exprR +++ procdefR
  82  
  83  sample = unlines
  84      ["proc tree n"
  85      ,"if n < 5 then stop"
  86      ,"fd(n)"
  87      ,"lt(30) tree(product(n,0.7))"
  88      ,"rt(60) tree(n * 0.7)"
  89      ,"lt(30) bk(n)"
  90      ,"end"
  91      ]
  92  
  93  {- |
  94  procdefR
  95  >>> read (head (lines sample)) :: Expr
  96  -}
  97  procdefR :: ReadP Expr
  98  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
  99  
 100  idenR :: ReadP String
 101  idenR = skipSpaces *> munch1 isLetter
 102  
 103  exprR :: ReadP Expr
 104  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
 105  
 106  arithexprR :: ReadP Expr
 107  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
 108  
 109  multiveR :: ReadP Expr
 110  multiveR = pfail
 111  
 112  callprocR :: ReadP Expr
 113  callprocR = EProcCall <$> idenR <*> many exprR
 114  
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2023-01-12 18:51:50.501760617
>>> readP_to_S exprR (head (lines sample))  
[]
2023-01-12 18:51:57.259487915
>>> read (head (lines sample)) :: Expr 
EProcDef "tree" ["n"]
2023-01-12 18:53:03.031384982
>>> Trouble loading CompilerPaths cache: GlobalDumpParseFailure
GHCi, version 9.2.5: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2023-01-17 10:52:17.436994254
>>> testR procdefR (sample !! 0)

<interactive>:1:1: error:
    Variable not in scope: testR :: t0 -> t1 -> t

<interactive>:1:7: error: Variable not in scope: procdefR

<interactive>:1:17: error: Variable not in scope: sample :: [t1]
2023-01-17 10:53:13.404268264
>>> :e src/Syntax.hs
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Numeric
   7  import Text.ParserCombinators.ReadP
   8  
   9  data Expr
  10      = ENum Float
  11      | EVar String
  12      | ERepeat Expr Expr
  13      | EBlock [Expr]
  14      | EWhen Expr Expr
  15      | EIf Expr Expr Expr
  16      | EProcCall String [Expr]
  17      | EArith Expr Bop Expr
  18      | ECompare Expr Rop Expr
  19      | EProcDef String [String]
  20      deriving (Eq, Show)
  21  
  22  isAtom :: Expr -> Bool
  23  isAtom (ENum _) = True
  24  isAtom (EVar _) = True
  25  isAtom _ = False
  26  
  27  -- instance Show Expr where
  28  --     show = showExpr
  29  
  30  showExpr :: Expr -> String
  31  showExpr e = case e of
  32      ENum x -> show x
  33      EVar v -> v
  34      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  35      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  36      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  37      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  38      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  39      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  40          where
  41              show' e | isAtom e = show e
  42                      | otherwise = "(" ++ show e ++ ")"
  43      EProcDef proc vs -> unwords (proc : vs)
  44  
  45  sample1 :: Expr
  46  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  47  
  48  data Bop
  49      = Add | Sub | Mul | Div deriving (Eq)
  50  
  51  instance Show Bop where
  52      show Add = "+" 
  53      show Sub = "-"
  54      show Mul = "*"
  55      show Div = "/"
  56  
  57  plusR :: ReadP Bop
  58  plusR = (skipSpaces *> (Add <$ string "+"))
  59      +++ (skipSpaces *> (Sub <$ string "-"))
  60  
  61  multR :: ReadP Bop
  62  multR = (skipSpaces *> (Mul <$ string "*"))
  63      +++ (skipSpaces *> (Div <$ string "/"))
  64  
  65  data Rop
  66      = Lt | Gt deriving (Eq)
  67  
  68  instance Show Rop where
  69      show Lt = "<"
  70      show Gt = ">"
  71  
  72  ropR :: ReadP Rop
  73  ropR = (skipSpaces *> (Lt <$ string "<"))
  74      +++ (skipSpaces *> (Gt <$ string ">"))
  75  
  76  --
  77  
  78  instance Read Expr where
  79      readsPrec _ = readP_to_S userInputR
  80  
  81  userInputR :: ReadP Expr
  82  userInputR =  exprR +++ procdefR
  83  
  84  sample = unlines
  85      ["proc tree n"
  86      ,"if n < 5 then stop"
  87      ,"fd(n)"
  88      ,"lt(30) tree(product(n,0.7))"
  89      ,"rt(60) tree(n * 0.7)"
  90      ,"lt(30) bk(n)"
  91      ,"end"
  92      ]
  93  
  94  {- |
  95  procdefR
  96  >>> read (head (lines sample)) :: Expr
  97  -}
  98  procdefR :: ReadP Expr
  99  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
 100  
 101  idenR :: ReadP String
 102  idenR = skipSpaces *> munch1 isLetter
 103  
 104  exprR :: ReadP Expr
 105  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
 106  
 107  arithexprR :: ReadP Expr
 108  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
 109              +++ multiveR
 110  
 111  multiveR :: ReadP Expr
 112  multiveR = EArith <$> aexprR <*> multR <*> aexprR
 113              +++ aexprR
 114  
 115  aexprR :: ReadP Expr
 116  aexprR = between (char '(' ) (char ')') exprR
 117          +++ numR
 118          +++ varR
 119          +++ repeatR
 120          +++ blockR
 121          +++ condR
 122          +++ outputR
 123          +++ stopR
 124          +++ callprocR
 125  
 126  numR :: ReadP Expr
 127  numR = ENum <$> (readS_to_P readFloat)
 128  
 129  varR :: ReadP Expr
 130  varR = EVar <$> idenR
 131   
 132  repeatR :: ReadP Expr
 133  repeatR = ERepeat <$> (skipSpaces *> string "repeat" *> exprR) <*> exprR
 134  
 135  blockR :: ReadP Expr
 136  blockR = EBlock <$> between (string "begin") (string "end") (many1 exprR)
 137  
 138  condR :: ReadP Expr
 139  condR = EIf <$> (skipSpaces *> string "if" *> exprR) 
 140              <*> (skipSpaces *> string "then" *> exprR) 
 141              <*> (skipSpaces *> string "else" *> exprR)
 142  
 143  outputR :: ReadP Expr
 144  outputR = pfail
 145  
 146  stopR :: ReadP Expr
 147  stopR = pfail
 148  
 149  callprocR :: ReadP Expr
 150  callprocR = EProcCall <$> idenR <*> many exprR
 151  
 152  testR :: ReadP Expr -> String -> [(Expr, String)]
 153  testR = readP_to_S
Ok, no modules loaded.
2023-01-17 10:53:42.29225117
>>> :l src/Syntax.hs
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2023-01-17 10:53:42.508152741
>>> testR procdefR (sample !! 0)

<interactive>:4:17: error:
    • Couldn't match type ‘Char’ with ‘[Char]’
      Expected: [String]
        Actual: String
    • In the first argument of ‘(!!)’, namely ‘sample’
      In the second argument of ‘testR’, namely ‘(sample !! 0)’
      In the expression: testR procdefR (sample !! 0)
2023-01-17 10:53:46.428379922
>>> testR procdefR (sample' !! 0)

<interactive>:5:17: error:
    • Variable not in scope: sample' :: [String]
    • Perhaps you meant one of these:
        ‘sample’ (line 84), ‘sample1’ (line 46)
2023-01-17 10:55:12.542392639
>>> :e
   1  module Syntax 
   2      where
   3  
   4  import Data.Char
   5  import Data.List
   6  import Numeric
   7  import Text.ParserCombinators.ReadP
   8  
   9  data Expr
  10      = ENum Float
  11      | EVar String
  12      | ERepeat Expr Expr
  13      | EBlock [Expr]
  14      | EWhen Expr Expr
  15      | EIf Expr Expr Expr
  16      | EProcCall String [Expr]
  17      | EArith Expr Bop Expr
  18      | ECompare Expr Rop Expr
  19      | EProcDef String [String]
  20      deriving (Eq, Show)
  21  
  22  isAtom :: Expr -> Bool
  23  isAtom (ENum _) = True
  24  isAtom (EVar _) = True
  25  isAtom _ = False
  26  
  27  -- instance Show Expr where
  28  --     show = showExpr
  29  
  30  showExpr :: Expr -> String
  31  showExpr e = case e of
  32      ENum x -> show x
  33      EVar v -> v
  34      ERepeat e1 e2 -> intercalate " " ["repeat", showExpr e1, showExpr e2]
  35      EBlock es -> intercalate " " (["begin"] ++ map showExpr es ++ ["end"])
  36      EWhen e1 e2 -> intercalate " " (["when"] ++ map showExpr [e1, e2])
  37      EIf e1 e2 e3 -> intercalate " " ["if", showExpr e1, "then", showExpr e2, "else", showExpr e3]
  38      EProcCall proc vs -> intercalate " " ([proc] ++ map showExpr vs)
  39      EArith e1 op e2 -> unwords [show' e1, show op, show' e1]
  40          where
  41              show' e | isAtom e = show e
  42                      | otherwise = "(" ++ show e ++ ")"
  43      EProcDef proc vs -> unwords (proc : vs)
  44  
  45  sample1 :: Expr
  46  sample1 = ERepeat (ENum 4) (EBlock [EProcCall "fd" [ENum 200], EProcCall "lt" [ENum 90]])
  47  
  48  data Bop
  49      = Add | Sub | Mul | Div deriving (Eq)
  50  
  51  instance Show Bop where
  52      show Add = "+" 
  53      show Sub = "-"
  54      show Mul = "*"
  55      show Div = "/"
  56  
  57  plusR :: ReadP Bop
  58  plusR = (skipSpaces *> (Add <$ string "+"))
  59      +++ (skipSpaces *> (Sub <$ string "-"))
  60  
  61  multR :: ReadP Bop
  62  multR = (skipSpaces *> (Mul <$ string "*"))
  63      +++ (skipSpaces *> (Div <$ string "/"))
  64  
  65  data Rop
  66      = Lt | Gt deriving (Eq)
  67  
  68  instance Show Rop where
  69      show Lt = "<"
  70      show Gt = ">"
  71  
  72  ropR :: ReadP Rop
  73  ropR = (skipSpaces *> (Lt <$ string "<"))
  74      +++ (skipSpaces *> (Gt <$ string ">"))
  75  
  76  --
  77  
  78  instance Read Expr where
  79      readsPrec _ = readP_to_S userInputR
  80  
  81  userInputR :: ReadP Expr
  82  userInputR =  exprR +++ procdefR
  83  
  84  sample = unlines sample'
  85  sample' = 
  86      ["proc tree n"
  87      ,"if n < 5 then stop"
  88      ,"fd(n)"
  89      ,"lt(30) tree(product(n,0.7))"
  90      ,"rt(60) tree(n * 0.7)"
  91      ,"lt(30) bk(n)"
  92      ,"end"
  93      ]
  94  
  95  {- |
  96  procdefR
  97  >>> read (head (lines sample)) :: Expr
  98  -}
  99  procdefR :: ReadP Expr
 100  procdefR = EProcDef <$> (string "proc" *> idenR) <*> many1 idenR
 101  
 102  idenR :: ReadP String
 103  idenR = skipSpaces *> munch1 isLetter
 104  
 105  exprR :: ReadP Expr
 106  exprR = ECompare <$> arithexprR <*> ropR <*> arithexprR
 107  
 108  arithexprR :: ReadP Expr
 109  arithexprR = EArith <$> multiveR <*> plusR <*> multiveR
 110              +++ multiveR
 111  
 112  multiveR :: ReadP Expr
 113  multiveR = EArith <$> aexprR <*> multR <*> aexprR
 114              +++ aexprR
 115  
 116  aexprR :: ReadP Expr
 117  aexprR = between (char '(' ) (char ')') exprR
 118          +++ numR
 119          +++ varR
 120          +++ repeatR
 121          +++ blockR
 122          +++ condR
 123          +++ outputR
 124          +++ stopR
 125          +++ callprocR
 126  
 127  numR :: ReadP Expr
 128  numR = ENum <$> (readS_to_P readFloat)
 129  
 130  varR :: ReadP Expr
 131  varR = EVar <$> idenR
 132   
 133  repeatR :: ReadP Expr
 134  repeatR = ERepeat <$> (skipSpaces *> string "repeat" *> exprR) <*> exprR
 135  
 136  blockR :: ReadP Expr
 137  blockR = EBlock <$> between (string "begin") (string "end") (many1 exprR)
 138  
 139  condR :: ReadP Expr
 140  condR = EIf <$> (skipSpaces *> string "if" *> exprR) 
 141              <*> (skipSpaces *> string "then" *> exprR) 
 142              <*> (skipSpaces *> string "else" *> exprR)
 143  
 144  outputR :: ReadP Expr
 145  outputR = pfail
 146  
 147  stopR :: ReadP Expr
 148  stopR = pfail
 149  
 150  callprocR :: ReadP Expr
 151  callprocR = EProcCall <$> idenR <*> many exprR
 152  
 153  testR :: ReadP Expr -> String -> [(Expr, String)]
 154  testR = readP_to_S
[1 of 1] Compiling Syntax           ( src/Syntax.hs, interpreted )
Ok, one module loaded.
2023-01-17 10:55:22.2599974
>>> testR procdefR (sample' !! 0)
[(EProcDef "tree" ["n"],"")]
2023-01-17 10:55:25.111253368
>>> :q
Leaving GHCi.
GHCi, version 9.2.5: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nanaka/logo2022/.ghci
2023-01-23 11:11:20.927940997
>>> :e src/Interact.hs
   1  module Interact where
   2  
   3  import Control.Concurrent.Chan
   4  import Control.Concurrent
   5  import System.IO.Unsafe
   6  import Graphics.Gloss
   7  import Graphics.Gloss.Interface.IO.Animate
   8  
   9  genericInteract :: IO [a] -> ([b] -> IO ()) -> ([a] -> [b]) -> IO () 
  10  genericInteract input output translate
  11      = output . translate =<< input
  12  
  13  outputPictures :: Chan Picture -> [Picture] -> IO ()
  14  outputPictures chan picts
  15      = forkIO (writeList2Chan chan picts) >> render chan
  16  
  17  render :: Chan Picture -> IO ()
  18  render chan
  19      = animateIO
  20          window0
  21          white
  22          (const (readChan chan))
  23          (const (return ()))
  24  
  25  window0 = FullScreen
Ok, no modules loaded.
2023-01-23 11:11:39.212293583
>>> :l src/Interact.hs 
[1 of 1] Compiling Interact         ( src/Interact.hs, interpreted )
Ok, one module loaded.
2023-01-23 11:11:39.317163958
>>> :t window0
window0 :: Display
2023-01-23 11:11:51.274351841
>>> :q
Leaving GHCi.
